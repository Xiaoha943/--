typora-root-url: ..\img

 ### 总结

#### 1.说一下`cookie sessionStorage localStorage`的区别？

相同：1. 都是浏览器本地存储 2.都遵循同源策略

| 不同点       | cookie                                                    | sessionStorage                                       | localStorage                                                 |
| ------------ | --------------------------------------------------------- | ---------------------------------------------------- | ------------------------------------------------------------ |
| 写入方式不同 | 由服务器端写入                                            | 由前端写入                                           | 由前端写入                                                   |
| 作用域不同   | 在所有同源窗口都是共享的                                  | 在不同的浏览器窗口共享，即使是同一个界面             | xxxxxxxxxx SAAS_CONFIG.currency//根据配置获取当前地区对应的币种typescript |
| 存储大小     | 不能超过4k（每次http请求都会携带cookie）                  | 5M                                                   | xxxxxxxxxx SAAS_CONFIG.currency//根据配置获取当前地区对应的币种typescript |
| 时效         | 只在设置的cookies过期时间之前一直有效，即使窗口浏览器关闭 | 仅在当前浏览器窗口关闭前有效                         | 始终有效，窗口和浏览器关闭也一直保存，作为持久数据           |
| 应用         | 用于存储登录验证信息sessionID或者token                    | 检测用户是否是刷新进入界面的，音乐播放器恢复进度条等 | 存储不易变动的数据，减轻服务器的压力                         |

<img src="/微信图片_20220920112633.jpg" style="zoom:67%;" />

1、生命周期： Cookie：可设置失效时间，否则默认为关闭浏览器后失效 Localstorage:除非被手动清除，否则永久保存 Sessionstorage：仅在当前网页会话下有效，关闭页面或浏览器后就会被清除 2、存放数据： Cookie：4k 左右 Localstorage 和 sessionstorage：可以保存 5M 的信息 

3、http 请求： Cookie：每次都会携带在 http 头中，如果使用 cookie 保存过多数据会带来性能问题 其他两个：仅在客户端即浏览器中保存，不参与和服务器的通信 

4、易用性： Cookie：需要程序员自己封装，原生的 cookie 接口不友好 其他两个：即可采用原生接口，亦可再次封装

 5、应用场景： 从安全性来说，因为每次 http 请求都回携带 cookie 信息，这样子浪费了带宽，所以 cookie 应该尽可能的少用，此外 cookie 还需要指定作用域，不可以跨域调用，限制很 多，但是用户识别用户登陆来说，cookie 还是比 storage 好用，其他情况下可以用 storage，localstorage 可以用来在页面传递参数，sessionstorage 可以用来保存一 些临时的数据，防止用户刷新页面后丢失了一些参数。

#### 2.输入URL到页面加载显示完成发生了什么？

**1.DNS解析:将域名解析为ip地址**

**2.TCP连接：TCP的三次握手**

**3.发送HTTP请求**

**4.服务器处理请求并返回HTTP报文**

OSI模型：应表会传网数物 五层协议：应传网数物

**5.浏览器解析渲染页面**

**6.连接结束：TCP四次挥手**

输入 url 后，首先需要找到这个 url 域名的服务器 ip,为了寻找这个 ip，浏览器首先 会寻找缓存，查看缓存中是否有记录，缓存的查找记录为：浏览器缓存-》系统缓存 -》路由器缓存，缓存中没有则查找系统的 hosts 文件中是否有记录，如果没有则查询 DNS 服务器，得到服务器的 ip 地址后，浏览器根据这个 ip 以及相应的端口号，构造一 个 http 请求，这个请求报文会包括这次请求的信息，主要是请求方法，请求说明和请 求附带的数据，并将这个 http 请求封装在一个 tcp 包中，这个 tcp 包会依次经过传输 层，网络层，数据链路层，物理层到达服务器，服务器解析这个请求来作出响应，返 回相应的 html 给浏览器，因为 html 是一个树形结构，浏览器根据这个 html 来构建 DOM 树，在 dom 树的构建过程中如果遇到 JS 脚本和外部 JS 连接，则会停止构建 DOM 树 来执行和下载相应的代码，这会造成阻塞，这就是为什么推荐 JS 代码应该放在 html 代码的后面，之后根据外部央视，内部央视，内联样式构建一个 CSS 对象模型树 CSSOM 树，构建完成后和 DOM 树合并为渲染树，这里主要做的是排除非视觉节点，比如 script，meta 标签和排除 display 为 none 的节点，之后进行布局，布局主要是确定各 个元素的位置和尺寸，之后是渲染页面，因为 html 文件中会含有图片，视频，音频等 资源，在解析 DOM 的过程中，遇到这些都会进行并行下载，浏览器对每个域的并行下 载数量有一定的限制，一般是 4-6 个，当然在这些所有的请求中我们还需要关注的就 是缓存，缓存一般通过 Cache-Control、Last-Modify、Expires 等首部字段控制。 Cache-Control 和 Expires 的区别在于 Cache-Control 使用相对时间，Expires 使用的 是基于服务器 端的绝对时间，因为存在时差问题，一般采用 Cache-Control，在请求 这些有设置了缓存的数据时，会先 查看是否过期，如果没有过期则直接使用本地缓 存，过期则请求并在服务器校验文件是否修改，如果上一次 响应设置了 ETag 值会在 这次请求的时候作为 If-None-Match 的值交给服务器校验，如果一致，继续校验 Last-Modified，没有设置 ETag 则直接验证 Last-Modified，再决定是否返回 304。

#### 3.浏览器在生成页面的时候，会生成哪两颗树？

构造两颗树，DOM和CSSOM规则树，

当浏览器接收到服务器相应来的HTML文档后，会遍历文档节点，生成DOM树，CSSOM规则树由浏览器解析CSS文件生成

#### 4. HTML5和CSS3新属性，在项目中的使用？

html5: header section footer aside nav main article figure

内容元素mark 高亮 progress 进度

表单： calander date time email url search

input : color date datetime email

canvas绘图中，支持内联SVG 

多媒体audio 、video、source

本地离线存储，需要离线存储在本地的文件列在manifest配置文件

web存储：localStorage SessionStorage

CSS3 边框如 border-radius，box-shadow 等；

CSS3 背景如 backgroundsize，background-origin 等；

CSS3 2D，3D 转换如 transform 等；

CSS3 动画如 animation 等。

#### 5.GET和POST的区别

GET 从指定的资源请求数据

POST 向指定的资源提交要被处理的数据

GET：不同的浏览器和服务器不同，一般限制在2-8K，更加常见的是1K以内

GET和POST的底层也是TCP/IP，GET/POST都是TCP链接

GET产生一个TCP包，POST携带两个TCP包

GET会将header和data一起发送出去，POST会先发送header请求返回100continue就再把data发送出去

**注：**

* 从缓存的角度：GET请求会被浏览器主动缓存下来，留下历史记录，而POST默认不会
* 从编码的角度：GET只能进行URL编码，只能接受ASCLL字符，而POST没有限制
* 从参数的角度：GET一般是放在URL中，因此不安全，POST放在请求体中，更适合传输敏感信息

#### 6. web性能优化

降低请求量：合并资源，减少HTTP请求数，minify/gzip压缩，webP，lazyLoad。

加快请求速度：预解析DNS，减少域名数，并行加载，CDN分发

缓存：HTTP协议缓存请求，离线缓存mainfest ，离线数据缓存localStorage

渲染：JS/css优化，加载顺序，服务器渲染，pipeline。

#### 7.tcp三次握手，一句话概括

客户端和服务端都需要知道各自可收发，因此需要三次握手

<img src="/image-20220708110424601.png" alt="image-20220708110424601" style="zoom: 25%;" />

第一次握手：客户端发送请求连接服务端确认，服务端确认可以接收客户端发送的报文段

第二次握手：客户端确认服务端收到了自己返送的报文段，并且确认自己可以接收服务端发送的报文段

第三次握手：服务端确认客户端收到了自己发送的报文段

#### 8.BOM属性对象方法

BOM是浏览器对象，

常用的BOM属性有：

**location对象**

loaction.href 返回或设置当前文档的URL

location.search 返回URL中的查询字符串部分 

:eagle: http://www.dreamdu.com/dreamdu.php?id=5&name=dreamdu 返回包括(?)后面的 内容?id=5&name=dreamdu

location.hash 返回URL#后面的内，如果没有#，如果没有#就返回空

localtion.host 返回URL中的域名部分，例如 www.dreamdu.com

loaction.hostname 返回URL中的主域名部分，例如dreamdu.com

loaction.pathname 返回URL的域名后的部分，例如 http://www.dreamdu.com/xhtml/ 返回/xhtml/

loaction.port 返回URL中的端口部分，例如 http://www.dreamdu.com:8080/xhtml/ 返回 8080

loaction.protocol 返回URL中的协议部分，例 如 http://www.dreamdu.com:8080/xhtml/ 返回(//)前面的内容 http:

location.assign 设置当前文档URL

location.repalce()设置当前文档的URL，并且在history对子昂的地址列表中移除这个URL  loaction.repalce(url)

location.reload()重载当前页面

**history 对象**

history.go(num) 前进或后退指定的页面数

history.back() 后退一页

history.forward() 前进一页

**Navigator对象**

navigator,userAgent 返回用户代理头的字符串表示

#### 9.fetch 发送2次请求原因

fetch 发送post请求的时候，总是发送两次，第一次状态码是204，第二次才成功，使用fetch的post请求的时候，导致fetch第一次发送了一个options请求，询问服务器是否支持修改的请求头，如果服务器支持，则在第二次中发送真正的请求。

 Fetch函数就是原生js、没有使用XMLHttpRequest对象、头部信息、请求信息、响应信息等均分布到不同的对象 标准回答 fetch是一种HTTP数据请求的方式，是XMLHttpRequest的一种替代方案。Fetch函数就是原生js，没有使用XMLHttpRequest对象。fetch()方法返回一个Promise解析Response来自Request显示状态（成功与否）的方法。 加分回答 XMLHttpRequest的问题 -所有的功能全部集中在一个对象上, 容易书写出混乱而且不容易维护的代码 -采用传统的事件驱动模式, 无法适配新的 Promise API Fetch API的特点 -精细的功能分割: 头部信息, 请求信息, 响应信息等均分布到不同的对象, 更利于处理各种复杂的数据交互场景 -使用Promise API, 更利于异步代码的书写 -同源请求也可以自定义不带 cookie，某些服务不需要 cookie 场景下能少些流量

#### 10.addEventListener 参数

addEventListener(event,funtion,useCapture)其中，event指定时间名，function指定要时间触发时执行的函数，useCapture指定事件是否在捕获或冒泡阶段执行

#### 11.介绍知道的http返回的状态码

100 continue 继续，客户端应继续请求

101 switching protocols 切换协议，服务器格局客户端的请求切换协议。只能切换到更高级的协议

200  OK 请求成功。一般用于GET和POST请求

201 Created 已创建。 成功请求并创建了新的资源

202 Accepted 已接受 。已接受请求，但并未处理完成

203 Non-Authoritative Information 非授权信息。请求成功，但返回的meta信息不在原始的服务器，而是一个副本

204 No Content 无内容。服务器成功处理，但未返回内容。在未跟心网页的情况下，确保继续显示当前文档

301 永久移动。请求的资源已被永久移动到新的URL，返回信息会包括新的URL

302 临时移动

303 查看其它地址

304 未修改，接口返回资源未修改

305 使用代理

306 已经废弃的http状态码

307 临时重定向

400 `Bad Request` 错误请求，客户端发送无效请求，服务端无法解析

401 `Unauthorized` 未经过授权，需要进行身份验证

402 保留，将来使用

403 `forbidden`请求被服务器拒绝，禁止访问。

404 `not found` 服务器资源未找到 

500 `internal Server Error` 服务器内部错误，无法完成请求，

501 `not implementhod`服务器不支持请求的功能，无法完成请求

502 `Bad Gateway`从远程服务器接受到了一个无效的响应

503 `Service Unavailable`由于超载后系统维护，服务器展示无法处理

#### 12.http支持的方法

GET、POST、HEAD、OPTIONS、PUT、DELETE、CONNECT

#### 13.画一个三角形

利用边框的均分原理

```javascript
.{
    width:0px;
    height:0px;
    border-top:10px soild red
    border-right:10px soild transparent;//透明
    borer-bottom:10px soild transparent;
    border-left:10px soild transparent;
}
```

#### 子元素高度和父级元素一致



#### 14.transition和animation的区别

annimation和transition大部分属性是相同的，他们都是随着时间改变元素的属性值，他们主要的区别是transiton需要触发一个事件才能改变属性，而animation不需要触发任何时间的青黄下会随着时间改变属性，animation是帧动画，可一帧一帧。

#### 15.垂直居中的方法

子绝父相

#### 16.visibility：hidden，opacity：0，dispaly：none

opacity：0该元素透明度为0，元素隐藏起来了，但不会改变页面布局，并且该元素若已经绑定一些事件如click时，点击该区域，也能触发点击事件

visbility：hidden，该元素隐藏起来了，但不会改变页面布局，也不会触发元素已经绑定的事件

dispaly：none 把元素隐藏起来，并且会改变页面布局，DOM元素节点删除移除

#### 17.浮动清除

方法一：使用clear属性的空元素，在浮动元素后使用的一个空元素

```css
<div class ="clear"></div>
.clear{
    clear:both;
}
```

方法二：使用CSS的overflow属性

给浮动元素的容器添加overflow：hidden或者overflow：auto清除浮动

#### 18.盒模型

CSS盒模型本质上是一个盒子，包括内边距、外边距、边框、内容

**标准盒模型：marggin+padding+border+content**

**IE盒模型和标准盒模型都是一个，但是内容的width和height计算不同**

**标准盒模型的content=content**

**但是IE盒模型的content=content+padding+border**

标准盒模型=content+margin(左右)+padding（左右）+border（左右）

怪异盒模型=content+margin(左右)（注：width包括padding左右和border左右）

设置盒模型“box-sizing:border-box

box-sizing：content-box



#### 19.选择器层级

!important>行内style>#id>.class

#### 19.重排重绘

重排：元素的视口改变或者元素大小位置显示隐藏发生改变会触发显示隐藏。

渲染过程：`DOM`树`（HTML）`和`CSSOM(CSS)`结合生成渲染树

重排、回流`（layout）` : 得到节点的几何信息（大小和位置）

新增DOM元素尺寸变化，窗口大小变化等

重绘`(Painting)` : 得到节点的绝对像素，将渲染树的每个节点转换成屏幕上实际像素展示

重绘：重排一般都会触发重绘，重绘不一定触发重排

减少重排重绘，可以通过

1. 使用cssText编写样式及样式改变时添加新的类名减少重绘。
2. 也可以通过将元素脱离文档流，例如先将元素进行隐藏，再进行元素的多次修改，再将元素显示出来，这样只会在显示和隐藏的时候触发重排重绘。复杂的样式使用绝对定位脱流文本流
3. 使用CSS3样式，比如transform、opacity、filters等是不会触发重排重绘的

**浏览器的渲染过程：**

1. 解析`HTML`,生成`DOM`树，解析`CSS`,生成`CSSOM`树
2. 将`DOM`树和`CSSOM`树结合，生成渲染树
3. `Layout`(回流/重排)：根据生成的渲染树，进行回流（layout）得到节点的几何信息（位置，大小）
4. `Painting`(重绘):根据渲染树以及回流得到几何信息，得到节点的绝对像素
5. `Display`：将像素发送GPU，展示在页面上。

#### 19.position相关属性

固定定位 fixed

相对定位 relative

绝对定位 absolute

粘性定位 sticky

静态定位 static

#### 20.css预处理器

less、sass等

#### 21.get请求传参长度的误区

get请求参数的限制是来源于浏览器或web服务器限制了url的长度

http协议未规定GET和POST的长度限制

GET的最大长度显示是因为浏览器和web服务器限制了URL的长度

#### 22.闭包

闭包就是

#### 23.类的创建和继承

原型链继承：

实例继承

构造继承

拷贝继承

寄生继承

组合继承

寄生组合继承

#### 24.如何·解决异步回调地狱

异步回调地狱 callback Hell 存在异步任务的代码，不能保证按照顺序执行

```
setTimeout(()=>{
     console.log('111')
      setTimeout(()=>{
         console.log('222')
          setTimeout(()=>{
          console.log('333')
          },3000)
      },2000)
},1000)
```

解决方法：

:poop: promise，promise本质不是控制异步代码的执行顺序，而是控制异步代码结果处理的顺序，promise本省只是一个容器，真正异步的是它的两个回调resolve()和reject()

1.promise 对象有三个状态：pending（进行中），fulfilled（已成功），rejected（已失败）

2.promise对象的的状态改变，只有两种可能：

a.从pending变为fulfilled*此时应该执行resolve*()

b.从pengding变为rejected此时应该执行reject()

3.promise在创建对象的时候。里面的代码会立即执行

a.promise创建时，里面的代买还是异步无序操作

b.promise的原理是，利用then方法将异步操作的结果，按照顺序执行，catch方法用来接受处理失败时相应的数据

4.promise解决回调地狱原理：在then方法中返回一个promise对象

**解决方法一：在上一个promise的then方法中返回下一个promise**

```javascript
function getData(url){
    return new Promise((resolve,reject)=>{
        $.ajax({
            url,
            success(data){
                resolve(data)
            },
            error(err){
                reject(err)
            }
        })
    })
}
//解决异步回调地狱问题再上一个promise的then方法中返回下一个promise
let url0 ='http://baidu0.com';
let url1 ='http://baidu1.com';
let url2 ='http://baidu2.com';
getData(url0).then((data0)=>{
    console.log(data0);
    return getData(url1)
}).then((data1)=>{
    console.log(data1);
    return getData(url2)
}).then((data2)=>{
    console,log(data2)
}).catch((err)=>{
    console,log(err)
})
```



:poop:async/await

一句话概括：async函数相当于是promise异步函数的另一种高级写法

async语法如下

1. 函数前面使用async修饰

2. 函数内部，promise操作使用await修饰

```javascript
const fs =  require("fs")

fuction getPromise(fileName){
    let p = new promise((resolve,reject)=>{
        fs.readFile(`./data/${fileName}.txt`,'utf-8',(err,data)=>{
            if(err){
                reject(errr)
            }else{
                resolve(data)
            }
        })
    })
    return p;
}

const readFile = async ()=>{
    let data1 = await getPromise('a')
    console.log(data1)
}
readFile()
```

```JavaScript
async function getCatch(){
    let result = await new promise((reject,resolve)=>{
        reject(new Error('登陆失败！'))
    }).catch((err)=>{
        console.log(err)//.catch()能捕获到错误信息
    })
    console.log('登录成功！')//但是成功信息也会执行
}

async function getCatch(){
    try{
    await new promise(function(resolve,reject){
        reject(new Error('登陆失败'))
    })
    conselo.log('登录成功！')//try抛出错误之后，就不会执行这条语句
    }catch(err){
       conselo.log(error)//catch语句能捕获到错误信息
    }
}
```

#### 25.前端中的事件流

事件流：事件流描述的是从页面中接受事件的顺序

DOM2级事件流包括一下几个阶段：

事件捕获阶段

处于目标阶段

事件冒泡阶段

addEventListener:addEventListener 是DOM2级事件新增的指定事件处理程序的操作，这个方法接受三个参数

**参数一：要处理的事件名**

**参数二:作为事件处理程序的回调函数**

**参数三：布尔值为true时表示在事件捕获阶段调用事件处理程序，为false表示在事件冒泡阶段调用事件处理程序**

#### 26.事件委托

不在事件发生的DOM节点上设置监听函数，通过事件冒泡，父元素可以监听到子元素的事件触发，通过判断事件发生元素

#### 27.图片的懒加载和预加载

预加载：提前加载图片，当用户需要查看时可以直接从本地缓存中渲染

懒加载：懒加载的主要目的是作为服务器前端的优化，减少请求数或延迟请求数

#### 28.手写深拷贝

```javascript
function deepClone(obj){
  var newObj =obj instance of Array ? []:{};
  for(var item in obj){
  var temple = typeof obj[item] == 'object'?  deepClone(obj[item]):obj[item];
  newObj[item] =temple
  }
  return newObj;
}
```

#### 29.数据类型

js有8种数据类型，分别为`undefined、Null、Boolean、Number、String、Object、Symbol、BigInt`

ES6新增数据类型：`Symbol、BigInt`

`Symbol`代表独一无二的值，用于定义对象的唯一属性名

`BigInt`可以表示任意大小的整数

**注：**引用数据类型数据存储在堆中，指针指向对应的栈中。

#### 30.数据类型的判断

`typeof`:判断所有值类型、函数。但是不能精确判断null、对象、数组，都会返回object

```javascript
console.log(typeof undefined)//undefined
console.log(typeof 'abc')//string
console.log(typeof 123)//number
console.log(typeof 435345435345345n)//bigInt
console.log(typeof Symbol("foo"))//symbol
console.log(typeof true)//boolean
console.log(typeof fuction (){})//function

//不能判断的
console.log(typeof [])//object
console.log(typeof {})//object
console.log(typeof null)//object

```

`instanceof`：用于判断对象类型，不能判断基本数据类型，其内部运行机制是判断在其原型链中能否找到该类型的原型

```javascript
class People{}
class student extends People{}
const temp = new student()

console.log(temp instanceof People)//true
console.log(student instanceof People)//true
```

`Object.prototype.toString.call()`所有原始数据类型都是能判断的。

```javascript
Object.prototype.toString.call(2)//"[object Number]"
Object.prototype.toString.call('abc')//"[object String]"
Object.prototype.toString.call(true)//"[object Boolean]"
Object.prototype.toString.call(null)//"[object Null]"
Object.prototype.toString.call(undefined)//"[object Undefined]"
Object.prototype.toString.call({})//"[object Object]"
Object.prototype.toString.call([])//"[object Array]"
Object.prototype.toString.call(function(){})"[object Function]"
```

#### 31.为什么0.1+0.2 !==0.3

原因：

**进制转换**：js在做数字计算的时候，0.1和0.2都会被转成二进制后无限循环，但是js采用的是IEEE 754二进制浮点运算，最大可以存储53位有效数字，于是大于53位后面的会全部截取调，导致精度丢失。

**对阶运算**：由于指数不相同，运算时需要对阶运算，阶小的尾数要根据阶差来右移（0舍1入），尾数位移时可能发生数丢失的情况，影响精度。

解决方法：

```javascript
function add(){
const maxLen = Math.max(a.toString.split('.')[1].length,
b.toString.split('.')[1].length
)
const base = 10**maxLen
const bigA = BigInt(base*a)
const bigB = bigInt(base*b)
const bigRes =(bigA+bigB)/BigInt(base)
return Number(bigRes);
}
```

#### 32.原型和原型链

#### 33.作用域和作用域链

作用域：最大的用处就是隔离变量，不同作用域下的变量不会有冲突，变量取值到创建这个变量的函数作用域内取值。

作用域链：一般情况下，变量的取值到创建该变量的函数作用域中进行取值，但是如果在当前作用域没有查到值，就会向上级作用域进行查找，一直查到全局作用域，查找的过程形成的链条为作用域链。

#### 34.执行上下文

总结：当javascript代码执行一段可执行的代码时，会创建对应的执行上下文，对于每个执行上下文，都有三个重要属性。

* 变量对象

* 作用域链

* this   

   			

#### 35.this指向问题

1. this没有指明指向时会直接指向window

2. this只能指向对象(普通对象)

3. 函数对象本身不能作为this的指向

4. 函数对象的实例对象/原型对象可以作为this的指向

5. 写在函数内的this如果有实例对象指向实例对象，如果没有则指向window

6. 在函数对象的原型对象内的this指向函数对象的原型对象

   [https://www.ruanyifeng.com/blog/2018/06/javascript-this.html]: 

#### 36.闭包

**在 JavaScript 中，每当创建一个函数，闭包就会在函数创建的同时被创建出来。可以在一个内层函数中访问到其外层函数的作用域。**

闭包防止变量污染

闭包应用： 函数作为参数被传递、函数作为返回值被返回：

应用实例：比如缓存工具，隐藏数据，只提供API

```javascript
cosnt x = (function aa(){
    var a =200
    return function bb(){
        a++;
        return a
    }
})()

console.log(x)//function bb(){ a++;return a}
console.log(x())//201
console.log(x())//202
//每次调用执行的都是function bb(){...}
```

```javascript
function print(fn){
    const a=200;
    fn();
}

const a =100
function fuc(){
    console.log(a)
}
print(fuc)//100
```

```javascript
function create(){
    const a=100;//
    return function (){
        console.log(a)
    }
}
cosnt fn =create();
const a =200;
fun()//100
```



#### 37.call、apply、bind实现

`call`:改变函数的`this`指向并且调用某个函数，第一个参数是需要被指向的那个对象，第二参数是参数列表`function.call(obj,当前函数参数一,当前函数参数二)`

`apply`：改变函数的`this`指向并调用某个函数，第一个参数是需要被指向的那个对象，第二个参数是数组或者类数组

`function.apply(objs,[参数一，参数二])`

`bind`

#### 38.new实现

1. 首先创一个新的空对象
2. 根据原型链，设置空对象的`_proto_`为构造函数的`prototype`
3. 构造函数的`this`指向这个对象，执行构造函数的代码
4. 判断函数的返回值类型，如果是引用类型，就返回这个引用类型的对象

#### 39.异步

1. event loop、宏观任务和微任务



#### 40.实现一个EventMitter类

### web存储

#### 41.cookie

* 本身用于浏览器和server通讯
* 被借用到本地存储来的
* 可用document.cookie ='...'来修改

缺点：

* 存储大小限制为4KB
* http请求时需要发送到服务端，增加请求数量
* 只能用document.cookies='.....'来修改

#### 42.http状态码

1. 状态码分类

   * 1xx-服务器收到请求
   * 2xx-请求成功，如200
   * 3xx-重定向，如302
   * 4xx-客户端错误，如404
   * 5xx-服务端错误，如500

2. 常见状态码

   * 200-成功
   * 301-永久重定向
   * 302-临时重定向
   * 304-资源未被修改
   * 403-没权限
   * 404-资源未找到
   * 500-服务器错误
   * 504-网关超时

3. http缓存

   * 关于缓存的介绍

   * http缓存策略（强制缓存+协商缓存）

   * 刷新操作方式，对缓存的影响

     ![](/微信图片_20220818151401.jpg)

​     Cache-Control：

* 在Response-Headers中
* 控制强制缓存的逻辑
* 例如Cache-Control：max-age=3153600(单位秒)

   Cache-Control有哪些值：

* max-age：缓存最大过期时间
* no-cache：可以在客户端存储资源，每次必须去福区段做新鲜度校验，来决定服务端获取新的资源(200)还是使用客户端缓存（304）
* no-store：永远都不要在客户端存储资源，永远都是取元素服务器去获取资源

![](/微信图片_20220818152503.jpg)

**注**:三种刷新操作对http缓存的影响

* 正常操作：地址看输入url，跳转连接，前进后退等

* 手动刷新：F5，点击刷新按钮，右键菜单刷新

* 强制刷新：ctrl+F5，shift+command+r

  **正常操作：强制缓存有效，协商缓存有效。**

  **手动刷新：强制缓存失效，协商缓存有效。**

  **强制刷新：强制缓存失效，协商缓存失效**

### React

#### 43.React事件机制，React16和React17事件机制的不同

#### 44.class component

1. 生命周期

   ![](/微信图片_20220819111722.jpg)

   * 初始化阶段：发生在`constructor`中的内容，在`constructor`中进行`state`、`props`的初始化，在这个阶段修改`state`，不会执行更新阶段的生命周期，可以直接对`state`赋值。

   * 挂载阶段：

     1. `componentWilMount`(发生在render函数之前，还没有挂载Dom)

     2. `render`

     3. `componentDidMount`(发生在render函数之后，已经挂载Dom)

   * 更新阶段：

     props更新时：
   
     1. `componentWillReceiveProps(nextProps,nextState)`这个生命周期主要是为我们提供props发生改变的监听，如果需要在props发生改变后，相应改变组件一些state。在这个方法中改变state不会二次渲染，而是直接合并state。
     2. `shouldComponentUpdate(nextPros,nextState)`这个生命周期需要饭后一个Boolean类型的值，判断是否需要更新渲染组件，优化react应用的主要手段之一，当返回false就不会向下执行生命周期了，在这个阶段不可以setState()，会导致循环调用。
     3. `componentWillUpdate(nextProps,nextState)`这个生命周期主要是给我们一个时机能够处理一些在Dom发生更新之前的事情，如获得Dom更新前某些元素的坐标
     4. `render`
     5. `componentDidUpdate(prevProps,preState)`此时已经完成渲染，Dom已经发生变化，state已经发生变化，prevProps、prevState均为上一个状态的值。
     
     state更新时：
     
     `shouldComponentUpdate`
     
     `conponentWillUpdate`
     
     `render`
     
     `compoentDidUpdate`
     
   * 卸载阶段
   
     1. `compoenntWillUnmount`在组件卸载销毁之前调用。再此方法中执行必要的清理操作，例如清除timer，取消网络请求或清除在`componetWillUnmount`中不应调用`setState`因为该组件将永远不会重新渲染，不会再进行挂载。
   
   * **注意：**官方建议删除的三个方法
   
     `UNSAVE_compoentwillMount`
   
     `UNSAVE_componentWillReceviveProps`
   
     `UNSAVE_componentWillUpdate`
   
     以下面两个新的取代：
   
     `static getDerivedStateFromProps(nextProps,nextState)`
   
     在组件实例化，接收到新的props。组件状态更新时被调用
   
     `getSnapshotBeforeUpdate(prevProps,prevState)`在这个阶段我们可以拿到上一个状态Dom元素的坐标、大小的相关信息。用于替代旧的生命周期中的`compoentWillUpdate`该函数的返回值会作为`compoentDidUpdate`的第三个参数出现。
   

#### 45.setState同步还是异步

`setState`本身代码的执行肯定是同步的，这里的异步是指多个`state`会合成到一个进行批量更新。同步还是异步取决于它被调用的环境

* 如果`setState`在React能够控制的范围别调用，就是异步的，比如合成事件处理函数，生周期函数，此时进行批量更新，也就是将状态合并后再进行DOM更新
* 如果`setState`在原生`javaScript`控制的范围被调用，它就是同步的，比如原生事件处理函数，定时器回调函数，Ajax回调函数中，此时`setState`被调用后会立即更新DOM。

#### 46.对函数式编程的理解

* **数据不可变性**：要求所有的数据都是不可变的，这意味着如果想修改一个对象，就必须创建一个新的对象来修改，而不是修改已有的对象
* **无状态：**强调对于一个函数，不管你何时运行，它都应该像第一次运行一样，给定相同的输入，完全不依赖外部状态的变化
* **便于测试优化：**由于纯函数对于相同的输入永远会返回相同的结果，因此我们可以轻松的断言函数的执行结果，同时也可以保证函数的优化不会影响其他代码的执行
* **可缓存性：**因为相同的输入总是可以返回相同的输出，因此可以提前缓存函数的执行结果
* **更少的bug**：不会出现不明指向的this，不存在对全局变量的引用，不存在对参数的修改，减少引发bug。

#### 47.react hooks

绘制首页编制管理显示

#### 48.伪类选择器、伪元素选择器

伪类：

1. :hover

2. :active 鼠标按下没有松开

3. :link 链接访问以前

4. :visited 链接标签被访问以后

   love hate顺序

5. first-child

6. last-child

7. nth-child(xn+y)

伪元素：

1. :: first-letter 选中第一个文字
2. ::first-line 选中第一行
3. ::selection 设置鼠标选中文字内容后的效果
4. :: placeholder 选中文本输入框里面的提示内容

#### 49.css常见样式

1. width/height
2. min-width/min-height
3. max-width/max-height
4. background-color设置背景颜色
5. background-image设置背景图片
6. bacground-repeat设置背景图的重复图片 
   * repeat-x
   * repeat-y
   * repeat
   * no-repeat
7. background-size设置背景图的大小
   * background-size:cover
   * background-sixe:contain
8. background-position设置背景图定位
9. background简写属性，
10. font-family
11. @font-face自定义字体
12. font-weight
13. font-style 设置字体样式
14. font-size设置字体大小
15. text-align 设置文字的水平对齐方式
16. text-decoration-line文字线条位置
    * underline 下划线
    * overline上划线
    * line-through
    * text-decoration-color设置线条颜色
    * text-decoration-style设置线条的类型
17. letter-specing
18. word-specing
19. line-height 设置文字的行高
20. border-radius圆角边框
21. overflow
    * visible
    * hidden
    * scroll
    * auto
22. opacity透明度
23. 显示隐藏
    * display：none(没有株连性，如果父元素隐藏后，子元素也不会显示出来)
    * visibility:hidden/visible(没有株连性，父元素隐藏子元素还是可以通过visibility:visible来重新显示)
    * opacity:0
24. 可以被继承的常用属性：color、font-*、text-*、line-height、visibility
25. 不可以被继承的常用属性：display、position、float、border、margin、padding、width
26. 主动继承  .div1>p { border:inherit }
27. **后代选择器**使用 空格 ，空格左右两边的选择器没有限制，可以使任何选择器
28. **子代选择器**使用>来表示，表示当前元素的子集元素
29. **相邻兄弟选择器**用+来表示
30. **普通兄弟选择器**用~来表示
31. **分组选择器**使用逗号,来表示
32. **属性选择器**使用[placeholder]来表示

#### 50.浮动定位float

1. clear : both 清除浮动的影响,在浮动元素的后面添加一个块级元素（一般我们会使用div元素），然后在这个元素上面添加`style="clear:both"`即可

2. 使用BFC恢复父级元素的高度，清除浮动的影响，常见的是overflow:auto 在浮动元素的父级元素上面（也就是高度坍塌的这个元素上面）添加`BFC`代码

3. ```javascript
   .div1::after{
      content:"";
      display:block;
      clear:both;
   }
   ```

#### 51.定位

1. position:relative相对定位 **没有脱流**

   ```
   .div1{
      position:relative;
      left:50px;
      top：80px;
   }
   ```

2. position：absolute 绝对定位 **脱流**

   ```
   .div1{
      position:absolute;
      left:50px;
      top:40px
   }
   ```

3. position：fixed 固定定位 **脱流**

#### 52.过渡

1. transition-property:width 执行过度的属性【必填】

2. transition-duration:2s ;执行过渡的时间

3. transition-timing-function:ease/linear线性 要执行过渡的时间函数

4. transition-delay 过渡延时等待

   ```
   transition: width 2s linear 3s;
   ```

#### 53.变换

##### 位移

1. transfrom : translateX(大小)沿着X轴方向发生位置变化

2. transfrom : translateY(大小)沿着Y轴发生位置变化

3. transfrom : translateZ(大小)沿着Z轴发生大小变化

4. transfrom : translate(水平方向，垂直方向)同时在水平方向X轴与垂直方向Y轴去设置位置变化

5. translate3d(x,y,z)三个方向同时发生位移

   左负右正，上负下正

##### 缩放

1. scaleX(倍速)沿着X轴进行缩放
2. scaleY(倍速)沿着Y轴进行缩放
3. scaleZ()
4. scale(水平，垂直)
5. scale(x,y,z)

##### 旋转

1. rotateX()沿着X轴旋转
2. rotateY()沿着Y轴发生旋转
3. rotateZ()沿着Z轴发生旋转

##### 倾斜

1. skewX()在X轴方向发生角度的倾斜
2. skewY()在Y轴方向发生角度倾斜
3. skew(X,Y)如果是一个值代表X轴，2代表xy

**`transform-style:preserve-3d`**必须开启

#### 54.渐变

```css
div{
   background-image:linear-gradient(to right,blue,green,red);
}
```

#### 55.动画

```JavaScript
@keyframes{
 from{//动画的开始
 
 }
 to{//动画结束
 
 }
}
```

```css
@keyframes box-ani{
   0%{
   transfrom:translate(0px,0px);
   }
   25%{
   transfrom:translate(200px,0px)
   }
   50%{
    transfrom:translate(200px,200px)
   }
   75%{
    transfrom:translate(0px,200px)
   }
    100%{
     transfrom:translate(0px,0px)
    }
}
```

```css
//帧动画
@keyframes box-ani{
    0%,25%{
        transfrom:translate(0px,0px);
    }
    25.1%，50%{
        transfrom:tranlate(300px,0px);
    }
    50.1%,75%{
        transfrom:tranlate(300px,300px)
    }
    75.1%,100%{
        transfrom:translate(0px,300px)
    }
}
```

##### 动画的使用

1. animation-name设置动画的名称*
2. animation-duration设置动画的播放一次的时间*
3. annimation-itration-count设置动画的执行次数，如果希望动画一直执行下去就设置infinite
4. animation-timing-function设置动画的时间函数，设置动画的效果，属性值和过渡保持一直 linear表示匀速默认是ease
5. animation-delay动画的等待时间默认是0秒
6. animation-direction设置动画的运行方向
   * normal正常
   * reverse方向反转
   * alternate正向与反向交替运行
   * alternate-reverse反向和正向交替运行
7. animation-play-state动画的播放状态
   * running
   * paused
8. animation-fill-mode动画的结束状态
   * backwards动画在借宿以后回到开始状态
   * forwards



#### 56.弹性盒子

**居中**

```css
//父元素弹性盒子
.div{
    diaplay:flex; 转换成弹性盒子
    flex-direction:row/column 设置主轴方向
    justify-content:center; 主轴对齐方式
    align-items:center; 交叉轴也就是副轴对齐方式
}
```

```css
//子绝父相
.father{
  position:relative;
}
.child{
    position:absolute;
    left:0;
    top:0;
    right:0;
    bottom:0;
    margin:auto;
}
```

```css
.father{
    未完待续。。
}
```

#### 57.ajax原生写法

```javascript
var xhr = new XMlHttpRequest();
var url ="http://www.baidu.com";
Xhr.open("get"，url,true)
Xhr.send();
Xhr.onreadyStateChange=()=>{
  if(xhr.readyState==4&&xhr.state==200){}
}
```

#### 58.深拷贝

```javascript
deepClone(obj){
    var _obj =JSON.stringfy(obj);
    return JSON.parse(_obj);
}

deepClone(obj){
    let newObj = Array.isArray(obj) ? []:{};
    for(x in obj){
        //证明x是obj本身的属性上不是在其原型链上
        if(obj.hasOwnProperty(x)){
            if(obj[x])&&typeOf(obj[x]) === 'object'){
           		newObj[x] = deepClone(obj[x])
            }else{
                newObj[x] = obj[x]
            }
         }
    }
    return newObj
}
```

#### 59.从发送一个url地址到返回界面，中间发生了什么？

1. 首先在浏览器地址栏输入URl
2. 浏览器查看浏览器缓存-系统缓存-路由缓存，如果缓存中有会直接在屏幕中显示页面的内容
3. 在发送http请求前，需要域名解析(DNS),解析获取相应的IP地址
4. 浏览器向服务器发送tcp链接请求，与浏览器建立tcp三次握手
5. 握手成功后，浏览器向服务器发送http请求，请求数据包
6. 服务器处理收到的请求，将数据返回至浏览器
7. 浏览器接收到HTTP响应
8. 读取页面内容，浏览器渲染，解析html源码
9. 生成Dom树，解析css样式，js交互
10. 客户端和服务器交互
11. ajax查询

#### 60.箭头函数的this会指向谁

箭头函数的this会跳过当前环境，去拿上一层的环境

#### 61.手写promise，promise原理，及参数

初始化&异步调用

then catch 链式调用

API  .resolve .reject .all .race

```javascript

function myPromise(){
    return p1 =new promise ((resolve,reject)=>{
        let result = this.servers()
        if(result.res =='SUC'){
           		resolve(result)
           }else{
               reject(result)
           }
    })
}
myPromise().then((data)=>{
    
}).catch((err)=>{
    
})

class myPromise{
    constructor(fn){
        cosnt resolveHandler =()=>{
            
        }
        const rejectHandler =()=>{
            
        }
        try{
            fn(resolveHandler,rejectHandler)
        }
    }
}

const p1 = new myPromise((resolve,reject)=>{
    resolve(100)
})

const p11 = p1.then((data)=>{
    return data+1
})
cosnt p12 = p11.then((data)=>{
    return data+2
})
const p13 = p12.catch((err)=>{
    alert(err)
})

const p2 = myPromise.resolve(200)
const p3 = myPromise.reject(‘错误信息)
const p4 = myPromise.all(p1,p2)
const p5 = myPromise.race(p1,p2)
```

#### 62.手写深拷贝

注意：深拷贝是复杂数据类型，复杂数据类型将数据地址存储在栈中，然后指向对应的堆中，浅拷贝只是复制了栈，但是还是指向同一个堆，复制后的值改变，前面的变量数据也会相应改变。

```javascript
fuction deepClone(obj){
    let objClone = Array.isArray(obj)?[]:{}
    if(typeof obj ==='Object'){
        for(key in obj){
           //方法接收一个字符串参数，该参数表示属性名称，判断该属性是否在当前对象实例中，而不是在原型链上
            if(obj.hasOwnproperty(key)){
               if(obj[key]&&typeof(obj[key])==='Object'){
                  objClone[key] =deepClone(obj[key])
                  }else{
                   objClone[key] =obj[key]
               }
             }
        }
     }
    return objClone
}
```

```javascript
fuction deepClone(obj){
  var _obj =JSON.stringfiy(obj);
  var objClone =JSON.parse(_obj);
  return objClone
}
```

#### 63.防抖和节流，及具体实现

**防抖：在规定的延迟时间内，只执行最后一次** 

官方解释：在事件被触发n秒后再执行回调，如果在这n秒内又被触发，则重新计时。（点击500次该按钮，只触发最后一次，只要一直触发这个事件，就一直清除上一个定时器，只留下最后一个定时器执行最后一次事件的最后的值）

```javascript
const debounce = (fn,delay)=>{
    let timer = null;
    return (...args)=>{
        if(timer){
           clearTimeOut(timer)
           }
     	timer = setTimeOut(()=>{
            fn.apply(this,args)
        },delay)
    }
}
```

**发送多次请求，只取最后一次请求返回的数据，前面的请求全部终止**

```react
const CancelToken = axios.cancelToken
export let planWeakReminderApiCancel =()=>{} //终止控制预警接口调用的方法

export function getPlanWeakReminderApi<T>(value):Promise<T>{
    return postHttp(pre+'/split-match/weak-reminder',value{
    cancelToken:new CancelToken((c)=>{
        //将axios中的取消调用方法赋值
        planWeakReminderApiCancel = c
    })
})
}

//页面调用获取预警接口前调用终止控制预警接口调用方法
const getWeakWarning = async()=>{
    //取消上次重复的调用
    planWeakReminderApiCancel()
    const res = await getPlanWeakReminderApi({...param})
}
```

**节流：在一定时间内只执行一次**。

官方解释：规定在一个单位时间内，只能触发一次函数。如果这个单位时间内触发多次函数，只生效一次。

```javascript
//节流 在一段时间内只执行一次
//当触发第一次方法时候，触发延时调用方法，此时flag一直为false则一直return出去，知道定时器时间结束，调用一次方法，且将flag改为true，下次不return，再次调用定时器中的方法
const throttle =(fn,delay)=>{
    let flag = true
    return (...args)=>{
        if(!flag){
            return
        }
        flag = false
        setTimeOut(()=>{
            fn.apply(this,arg)
            flag = true
        },delay)
        
    }
}
```

#### 64.ES6常用属性

1. 变量的定义  let :let定义的变量不能再定义变量之前调用 ，作用域{}，不允许多次定义，没有就送外部调用const：在定义之前调用，{}作用域，不能再一个作用域内多次定义，定义的值不能改变

2. 解构 ... let [x,y,z] =['1','2','3'] let {stuName,stuSex,stuAge} =stu [b,a]=[a,b] ...可以把一个具备Iterable接口的数据展开

   ```javascript
   let arr =[1,2,3,45,56]
   console.log(...arr)//1,2,3,45,56
   let max = math.Max(...arr)//56
   console.log(...obj);//ERR代码在这里会报错
   
   let arr1 =['a','b','c'...arr]
   //深拷贝数组方法
   let arr = [1,2,3,4,5]
   let arrBackUps = [...arr]//arrBackUps是深拷贝后的数组
   
   //对象的深拷贝
   let objBackUps ={...Obj1}
   let obj2 ={...obj1,age:18}
   
   ```

3. 字符串的扩展

   ```javascript
   `${userName}`
   `${age>=18?'成年人':'未成年'}`
   `大家好我开始背面试题了，现在是${time}`
   ```

   * length 属性，代表字符串的长度
   * indexof()方法，在字符串中查询某个元素所在的索引位置
   * lastIndexof()从后向前找索引，找不到就是-1
   * replace()方法，替换字符串
   * slice(start,end)方法，截取字符串，注意，这个方法与数组保持一致，start与end都可以取负值
   * substring(start,end)方法，截取字符串，但他不适用负值
   * substr(start,length)方法，截取字符串，但是第二个参数是长度
   * toUpperCase()方法，转换成大写字终
   * toLowerCase()方法，转换成小写字终
   * search()方法，查询符合要求字符的位置，它与indexof()很像，但是search要求支持正则表达式
   * split()方法，将字符串按照符合要求的格式是拆分成数组
   * trim()去除字符串左右的空格
   * trimLeft()/trimRight()方法，去除左边或右边的空格
   * trimStart()/trimEnd()方法，除去开始与结束的空格
   * includes()当前字符串是否包含某个字符
   * mach()方法根据正则表达式匹配符合要求的内容
   * matchAll()方法，根据正则表达式匹配符合要求的内容，它的正则表达式必须的修饰符
   * concat()方法与数组里面的方法保持一直，拼接一个字符串，形成一个新的字符串，原字符串不变
   * String.fromCharCode()方法，从某一个ascII码得到一个字符

4. 数组的扩展

   * Array.isArray()方法
   * Array.of()
   * Array.from()将一个类数组转换成数组
   * Array.prototype.fill()方法指定的值填充数组
   * Array.prototype.flat(steps)方法，拍平数字
   * Array.prototype.findIndex()方法，根据要求查找指定的元素的索引位置
   * Array.prototype.find()根据要求查找元素

5. Set单值集合

   一个没有索引key的不重复的数组

   let s2 =new Set(['a','b','c','c','d'])//{"a","b","c","d"}

   ```javascript
   let arr =[1,2,2,3,4,5,6]
   let se1= new Set(arr)
   let arr1 =Array.from(se1)
   let arrBackUps = [...arr1]
   ```

   * size属性，获取当前这个集合里面的元素数量

   * add向集合中增加一个元素

   * delete从集合中删除一个元素

   * has判断一个与元素是否在集合里面

   * clear清空当前集合

   * values获取当前set容器里面的值的集合，返回一个迭代器

   * keys获取当前set容器里面的键的集合，返回一个迭代器

     **只能使用for.... of进行遍历**

6. 函数的扩展

   ```javascript
   let obj ={
       age:18,
       student:function (){
           this.userName ='hanjingwen'
       }
   }
   let s1 = new obj.student()
   ```

   

7. 对象的扩展

   ```javascript
   
   ```

   

8. 数据类型的扩展

9. 结构的扩展

10. 反射与代理

    ```javascript
    reflect.get()//获取某个对象的某一个属性
    reflect.set()//设置某个对象的，偶一个属性值
    reflect.apply()//通过原来的apply的方式调用一个方法
    reflect.defineProperty//在某一个对象上面定义属性
    reflect.deleteProperty//在某一个对象上删除某一个属性
    ```

    ```javascript
    proxy
    ```

    

11. symbol数据类型

    ```javascript
    //这是ES6的新数据类型当中的第七种数据类型，
    //全局唯一标识符
    var a = Symbol('我创建');//这就生成了一个全局唯一标识符
    var b = Symbol('123');//
    console.log(a==b);//false	
    
    //Symbol.for 如果在开发过程中，我们要使用相同的symbol值，可以使用Symbol.for
    let a = Symbol.for("aaaa");//指定这个全局唯一标识符所生成的内容
    let b = Symbol.for("aaaa");
    console.log(a==b)//true
    
    //Object.getOwnPropertySymbols获取某一个对象的symbol属性
    
    var obj ={
        userName:"hanjingwen",
        age:18,
        [symbol()]:"hello"
    }
    Object.keys(obj)//["userName","sex","age"]
    Object.getOwnPrppertuSymbols(obj)//这里获取到symbol
    ```

    

12. 生成器与迭代器

    ```javascript
    //生成器函数叫Generator生成器Generator生成器函数
    function abc(){
        return 'hello'
    }
    let str = abc()
    console.log(str)
    //迭代器，迭代的意思是从一个对象内部一个一个的把内容拿出来
    
    ```

13. 同步与异步的扩展

14. 模块化

#### 65.canvas

```javascript
<canvas id="c1" width:"400px" height:"400px"></canvas>

var c1 = document.getElementById("c1");
var ctx = c1.getContext("2d")
ctx.fillStyle ='red'//代表填充的颜色
ctx.strokeStyle ='green'//代表搭边的颜色
ctx.lineWidth ='1px';//代表搭边的线条宽度
ctx.stroke()//将之前的路径描出来
ctx.fill()//将之前的路径填充，但是填充的时候一定要是闭合的路径
ctx.lineCap ="butt"//设置线条末端的样式，有平头butt，圆头round，方头square
ctx.save()//保存当前的配置，配置入栈
ctx.retore()//还原配置，配置出栈

//绘制矩形
ctx.fillRect(x,y,w,h)//填充矩形
ctx.strokeRect(x,y,w,h)//描边一个矩形
ctx.clearRect(z,y,w,h)//清除一个矩形区域

//绘制路径
ctx.beginPath()//开始一个新的路径，是从原点开始的
ctx.closePath()//将路径闭合（第一个点和最后一个点连起来）
ctx.lineTo(x,y)//上一个点画到x,y这个点
ctx.moveTo(x,y)//将画笔移动到x,y这个点
```

#### 66.上传、下载文件的步骤

```javascript
//上传文件
//1. 获取或者创建input的DOM节点
const input = document.createElement('input');
//2.设置input type为file，name为file1
input.setAttribute('type','file');
input.setAttribute('type','file1');
//3.监听当前文件上传框
input.onchange =(event)=>{
    //当文件框改变也就是上传时获取上传的文件信息
    cosnt fileObj = input.files[0];
    //判断获取的文件数据不为空，且文件大小不小于0
    if(typeof (fileObj)==='undefined || file.size <= 0'){
       return
       }
    //获取文件名和文件类型
    const fileName = fileObj.name;
    const fileType = fileName.subString(fileName.lastIndexOf('.')+1,fileName.length)
}
    const typeArr = ['doc','docx','ppt','pptx','pdf','xls','xlsx','txt','jpg']
    if(!typeArr.includes(fileType){
       Alert('所选文件格式不符合要求！');
       return;
       }
    if(fileObj.size > 20971520){
       Alert('所选文件大小不能大于20MB，请重新选择！');
       return;
       }
    this.uploading =true
    //4.获取表单文件上传数据
    const fromFile = new FromData();
    fromFile.append('file',fileObj);
    fromFile.append('arcNum',this,bean.ARC_NUM);
    fromFile.append('arcDate',this,bean.ARC_DATE);
const that = this;
// 5.发送ajax请求，将表单的input上传的文件数据POST传入接口
$.ajax({
    url:enviroment.apiBase+'/archives/file/upload',
    data:fromFile,
    type:'POST',
    dataType:'json',
    //上传文件无需缓存
    cache:false,
    //对于data参数进行序列化处理，这里必须FALSE
    processData:false,
    contentType:false,
    beforeSend:(xhr)=>{
        xhr.setRequestHeader('MOCK-UID',encodeURIComponent(uid));
    },
    success:(response)=>{
        if(res instanceof Array){
           if(res[1].SVRRTN === 'Y'){
              that.do(res[0])
              }
           }
    },
    error:(response)=>{
        that.uploading =false;
        that.showAlert('文件上传失败！')
    }
    
})

//下载文件
file_download(){
    const curitem =this.data.currentItem;
    if(curitem != null){
       if(this.dowmloading){
           this.showAlert('有文件在下载，请稍等！')
           return
       }
       this.downloading =true;
        const fileDeleteBean =new FileBean();
        fileDeleteBean.fileId -curitem.ID;
        const that = this;
        window.URL =(window as any).webkitURL || window.URL;
        const uid =MAIN_PAGE.getInstance(null).USER_LOGINNAME;
        $.ajax({
          url:url,
          data:JSON.stringify(filrDeleteBean),
          type:'POST',
          cache:false,
          processData:false,
          xhrFields:{
              responseType:'blob'
          },
          beforeSend:()=>{
              xhr.setRequestHeader('MOCK-UID'，encodeURIComponent(uid))
          },
          success:()=>{
              const myBlob = new Blob([data]);
              const url =window.URL.createObjectURL(myBlob);
              const linkElement =document.createElement('a');
              linkElement.setAttribute('herf',url);
 linkElement.setAttribute('download',curitem.FILE_NAME);
              const clickEvent =new MouseEvent('click',{
                  'view':window,
                  'bunnles':true,
                  'cancelable':false
              });
              linkElement.dispatchEvent(clickEvent);
              that.downloading =false;
          },
          error:(res)=>{
              that.downloading =false;
              that.showAlert('文件下载失败！')
          }
        })
    }else{
        this.showAlert('请先选择数据！')
    }
}

   
```

#### 67.面试问题汇总

1.常规客套
2.自我介绍，之前做过哪些项目，主要用的是哪些技术栈?（vue.js用的比较多）

3.针对性问答
3－1.你们为什么要选择vue.js呢，它给你们解决了什么问题?
3－2.谈谈对vue生命周期的理解?
3－3.v-if 和 v-show有什么区别?
3－4.vue.js中组件之间是如何通信的?
3－5.vue中数据双向绑定原理了解吗？
3－6.如果让你实现一个基本的双向数据绑定，那你是什么思路呢？
3－7.MVVM和MVC有什么区别?
3－8.有没有用过其他的JS框架?
3－9.对前端代码的自动化测试有没有了解?有没有使用过前端代码自动测试框架呢？

第四部分_JS基础
4－1.说说JS中的数据类型
4－2.JS中的 ＝＝和＝＝＝有什么区别？
4－3.JS中的深拷贝和浅拷贝有什么区别？
4－4.如果让你实现一个深拷贝，有什么思路?
4－5.简述一下对原型，构造函数以及实例的理解
4－6.什么是闭包?闭包解决了什么问题？闭包会导致什么问题呢？

缺点是生成多个不销毁的私有作用域（堆内存），对性能有一定的影响。 4－7.如何理解JS中的this关键词?
4－8.之前有没有解决过跨域问题?在你们项目里。当时是怎么解决的?

CSS基础篇
1.P元素和div元素，都是块元素，两者之间有什么区别呢？
2.谈谈你对CSS盒子模型的理解?
3.如何水平垂直居中一个页面元素?还有什么其他方式吗？
4.清除浮动的方式有哪些?他们之间有哪些区别?
5.重绘和回流有什么区别？
6.（你说你做过移动端开发，对响应式布局了解吗？）实现响应式布局有哪些方式?
7.有没有用过一些CSS框架?
8.当我在浏览器中输入URL，一直到页面显示，这个中间过程发生了哪些事情呢？（说的越具体越好
）
9.说几条web前端的优化策略吧。

第五部分，综合能力
1.你在项目中遇到过哪些大坑，那当时是怎么解决的?
2.在你们团队中，你有没有一些突出的亮点可以在这分享一下
3.那你提到前端工程实践，那项目中的package.json有什么作用?它里面都有哪些内容?
6.对webpack比较熟是吧，那你对webpack的使用有哪些优化建议呢？

7.你平常业余时间都是怎么学习的呢，看什么书，浏览什么网站？
8.职业规划是什么样的呢？
9.你对我们这边还有什么问题吗?

#### 68..说说JS中的数据类型?

答：js中有基本数据类型： `number、string、boolean、undefined、null、 引用数据类型array、Object，ES6中新添加的bigInt、symbol`

#### 69.JS中的 ＝＝和＝＝＝有什么区别？

答：两个等于是指值相等，数据类型不同也可能相等，比较时候会进行数据类型转换。

三个等于是全等于，会进行值和数据类型的比较，只有数据类型相等且值相等才是全等于

#### 70.js的深拷贝和浅拷贝有什么区别？

答：js中的对象和数组数据类型 是存在栈和堆，引用地址存在栈中，数据存堆中，由引用地址栈指向指向堆，进行数据的查找和修改，浅拷贝只是进行了栈的拷贝，但是拷贝后的数据还是会指向原来的堆，修改拷贝后的数据会更改原来被拷贝的值，而深拷贝是进行栈和堆的一起拷贝，不回影响原来的的值。

可以通过对象的序列化和反序列化进行深拷贝

使用递归的方法进行深拷贝：

```javascript
function deepClone(obj){
    const cloneObj = Object.protoType.toString.call(obj)==='[object Object]'?{}:[];
    for(key in obj){
        if(obj.hasOwnProperty(key)){
           if(typeof(key)==='Object'){
               cloneObj[key] = deepClone(obj[key]) 
              }else{
               cloneObj[key] = obj[key]
           }
        }
    }
    return cloneObj
}
```

#### 71.简述一下对原型，构造函数以及实例，原型链的理解

构造函数：一般用来创建实例化的对象。

```javascript
let p1 = new persen()
```

对象：1.对象是单个实物的抽象2.对象是一个容器，封装了对应属性和方法。**属性是对象的状态，方法是对象的行为**

构造函数：1.函数体内使用this关键字，代表所要生成的对象实例

原型对象：Foo.prototype。

实例对象：f1就是实例对象，每个实例对象f1都有一个私有属性称之为（proto）指向它的构造函数的原型对象（prototype），每个实例对象都有一个constructor是通过继承关系继承来的。它指向当前的构造函数Foo。

构造函数：用来初始化创建对象的函数，**Foo是构造函数，自动给构造函数赋予prototype属性，该属性指向实例对象的原型对象。**

```javascript
function Foo(){
    Foo.prototype.showName = function (){
        console.log('dongdong')
    }
}
var f1 = new foo()
var f2 = new foo()
console.log("f1.showName():",f1)
console.log("f1.showName():",f2)
f1.showName();
f2.showName();

function Foo()//构造函数
let F1 = new Foo()//实例对象
console.log("f1",f1)
console.dir(Foo)
console.log(Foo.prototype === F1.proto)//true

```

<img src="/prototype.jpg" style="zoom:67%;" />

原型链：

1. 根据原型链查找，如果一层一层往上查找，所有的对象的原型最终都可以寻找到Object.prototype.Object构造函数的prototype
2. 所有的对象都继承了Object.prototype上的属性和方法
3. 读取属性和方法的规则:js引擎会先寻找对象本身的属性和方法，如果找不到就去它的原型对象上去查找，如果还找不到到就到原型的原型去找，直到查找到最顶层的Object.prototype还是找不到，如果对象和它的原型，都定制了同名属性，那么邮箱读取对象自身的属性，这也叫覆盖。

<img src="/C:/Users/xiaoha/AppData/Roaming/Typora/typora-user-images/1669291513431.png" alt="1669291513431" style="zoom:150%;" />

**注意：**实例首先在自身的属性上去查找，若查找不到就到隐式原型上去查找，对应的就是类的的显示原型方法。

每个实例都有隐式原型，每个类都是显示原型

实例的隐式原型指向class的显示原型

![1669454686609](/C:/Users/xiaoha/AppData/Roaming/Typora/typora-user-images/1669454686609.png)

原型链：student.prototype.__proto__ === People.prototype

People.prototype.proto === Object.prototype

instance of是顺着原型链进行查找

#### 72.面试题：

##### css面试题：

如何理解HTML语义化？

1.代码可读易读例如:<h1></h1> <p></p><ul><li></li></ul>而不是只用<div>

让搜索引擎更容易读懂

那些标签是块级元素，哪些是内联元素？

块级元素：`dispaly:block`主要有 div p ul ol table h1 h2

行内元素/行内块级元素：`display:inline/inline-block`主要有 span image input button 

###### **css布局：**

盒子模型的宽度如何计算？

offsetWidth =(内容宽度+内边距+边框)，无外边距

让width=== offsetWidth 需要设置：box-sizing：border-box；

margin纵向重叠的问题

相邻元素的margin-top和margin-botto会发生重叠

空白内容的<p></p>也会重叠

```css
p{
    font-size：16px;
    line-height:1px;
    margin-top:10px;
    margin-bottom:15px;
}
<p>AAA</p>
<p></p>
<p></p>
<p>BBB</p>
之间的距离是：15px

```

margin负值的问题

BFC的理解和应用

float布局的问题，以及clearfix清除浮动

flex画色子

###### **css定位：**

absolute和relative分别一句什么定位？

居中对齐有哪些实现方式？

###### **css图文样式：**



##### js基础知识：

###### typeof可以判断哪些类型：

可以识别所有值类型，string undefined number boolean symbol('s') 识别函数，识别是不是引用类型'object' 'function'

##### instance of 判断数据类型

只能判断对象类型，原理是：根据原型链向上查找一直找到原型链顶层

```javascript
instanceOf({})// object
instanceOf(null)//object
instanceOf([])// array
```

全部类型都可以判断，通用方法：

```javascript
Object.prototype.toString.call({}) [object,Object]
Object.prototype.toString.call([])
[object,Array]
Onject.prototype.toString.call(null)
[object,Null]
```



###### **何时使用===何时使用==：**

==会实现类型转换，===值和类型都相等

truely变量

falsely变量：'' 0 false undefined null NaN 除此之外的都是truely变量

###### **值类型和引用类型：**

值类型都是存储在栈中 如string undefined number boolean symbol('s')

引用类型存储了内存地址在栈中指向堆的值，栈从上往下加，堆是从下往上加 如array object  function null

值类型都是存储在栈中，如string undefined number boolean symbol

引用类型存储了内存地址在栈中指向堆的值，栈从上往下加，堆是从下网上加，Array object function  null

###### **手写深拷贝：**

```javascript
function deepClone(obj){
    const cloneObj = Object.prototype.toString.call(obj)==='[object Object]'? {}:[];
    for(key in obj){
        if(obj.hasOwnproperty(key)){
           if(typeof(obj[key])==='object'){
              cloneObj[key] = deepClone(obj[key])
            }else{
              cloneObj[key] = obj[key]
            }
         }
    }
    return cloneObj
}
```

###### **class:**

```javascript
class People(){
    constructor(name ,action){
        this.name =name;
        this.action =action
        
    }
    sayHi(){
        `我叫${this.name},我要去${this.action}`
    }
}

class (){
    constructor(study){
        super(name)
        this.study = study
    }
    
    study(){
        `我叫${this.name},我要去${this.study}`
        
    }
}

class Teacher(){
    constructor(teach){
        super(name)
        this.teach =teach
    }
    
    teach(){
        `我叫${this.name},我要去${this.teach}`
    }
}
let som =new Student('学习')
let Tom =new Teacher('教学')
som.study()
Tom.teach()
```

###### **如何准确判断一个变量是不是数组：**

instance of Array

###### **class的原型本质：**

原型和原型链的图示

###### **属性和方法的执行规则：**

原型链的执行方法

###### **简易的jquery的实现：**

```javascript
class jQuery{
    constructor(selector){
        cosnt result = document.querySelectorAll(selector);
        const length = result.length
        for(let i;i<length;i++){
            this[i]=result[i]
        }
        this.length = length
        this.selector = selector
    }
    get(index){
        return this[index]
    }
    each(fn){
        for(let i; i<length;i++){
            const elem = this[i];
            fn[elem]
        }
    }
    on(type,fn){
        return this.each(elem=>{
            elem.addEventListener(type,fn,false)
        })
    }
}

html:
<p>一段文字</p>
<p>一段文字</p>
<p>一段文字</p>
<p>一段文字</p>

const $p = new jQuery('p')
$p.get(1)
$p.each((item)=>{
    console.log(item.nodeName)//ppp
})
$p.on('click',()=>{
    this.alert('我被点击了！')
})
插件：
jQuery.prototype.dialog=(info)=>{
    alert(info)
}
造轮子：
class myJQuery extens jQuery{
    constructor(selector){
        super(selector)
    }
    addClass(className){
        
    }
    style(){
        
    }
}
```

###### 作用域？自由变量：

作用域：

函数作用域、全局作用域、块级作用域

自由变量:
一个变量在当前作用域未被定义，但是使用到了

向上级作用域去一层层查找，直到找到为止，如果到全局作用域都没找到，就报错xx is not defined

```javascript
//每次点击a标签，都会alert数字10，因为界面已经渲染完，i是全局作用域，循环结束后i就是10.
let i ,a 
for(i=0;i<10;i++){
    let a = document.createElement('a');
    a.innerHTML = i +'<br>'
    a.addEventListener('click',(e)=>{
        e.preventDefault();
        alert(i);
    })
}
document.body.appendChild(a);//10 10 10 10...

//每次点击a标签，会弹出对应位置数字，i是在for循环内调用，每次循环都会形成独立的i，互不影响
let a 
for(let i=0;i<10;i++){
    let a = document.createElement('a');
    a.innerHTML = i +'<br>'
    a.addEventListener('click',(e)=>{
        e.preventDefault();
        alert(i);
    })
}
document.body.appendChild(a);//1 2 3 4...
```

###### 闭包

每创建一个函数，闭包就会在函数创建的同时被创建出来。可以在一个内层函数中访问其外层函数的作用域。

闭包是指能被访问自由变量的函数。自由变量是指在函数中使用的，但既不是函数参数也不是函数的局部变量的变量。闭包=函数+函数能够访问的变量

1.函数作为参数，被传入

```javascript
function print(fn){
    let a= 20
    fn()
}
let a = 10
function fn(){
    console,log(a)
}
print(fn)//10
注意：闭包自由变量的查找，是在函数定义的作用域向上查找，不是在执行的地方向上查找
```

2.函数作为返回值被返回

```javascript
function fn(){
    let a=10;
    return function(){
        console.log(a)
    }
}
let a=20
fn()//10

```

```javascript
//例闭包隐藏数据
fuction createCache(){
    const data ={}//闭包中的数据被隐藏，不被外界访问
    return {
        set:function (key, val){
            data[key] = val
        },
        get:function (key){
            return data[key]
        }
    }
}

const c = createCache();
c.set('0','测试');
c.get('0');//'测试'
```

作用：避免变量污染

缺点：变量会导致占用内存空间，不会销毁

**注意：闭包中的自由变量的查找，是在该函数定义的的作用域向上查找，不是在函数值执行的地方**

this的不同作用场景

在class方法中调用：

```javascript
const zhangsan ={
    name:'张三'，
    sayHi(){
        //this即当前对象
        cosole,log(this)
    },
    wait(){
        setTimeOut(()=>{
            console.log(this)
            //this即当前对象
        })
    }
}

const zhangsan ={
    name:'张三'，
    sayHi(){
        //this即当前对象
        cosole,log(this)
    },
    wait(){
        setTimeOut(function(){
            console.log(this)
            //this===window
        })
    }
}
```

箭头函数：

永远是取上级函数的作用域对象

###### 异步和单线程

1. 同步和异步的区别是什么？

   ```javascript
   //js是单线程语言,异步不会阻塞代码执行，同步会阻塞代码执行。
   ```

2. 手写用promise加载一张图片

   ```javascript
   function loadImg(src){
       const p = new promise(
           (resolve,reject)=>{
               let img = document.createElement('img');
               img.onLoad=()=>{
                   resolve(img)
               }
               img.onerror =()=>{
                   const err = new Error(`图片加载失败${src}`)
                   reject(err)
               }
               img.src = src;
           }
       )
       return p
   }
   
   //解决异步回调地狱，在上一个then返回下一个promise
   let src0 = 'http://0';
   let src1 = 'http://1';
   loadImg(src0).then((img0)=>{
       console.log(img0.width);
       return loadImg(src1);
   }).then((img1)=>{
       console.log(img1.height)
   }).catch((err)=>{
       console.log(err)
   })
   ```

3. 前端使用异步的场景有哪些？

   ```javascript
   //网络请求，ajax异步加载图片
   //setTimeOut定时器，循环定时器
   ```

* 单线程和异步

  js是单线程语言，只能同时只能做一件事，异步不会阻塞代码执行，同步会阻塞代码执行。

  浏览器和nodejs已支持js启动进程，如Web Worker

  JS 和DOM渲染共用同一个线程，因为JS可修改DOM结构

* 应用场景：遇到网络请求、定时任务不能卡住，需要异步

* callback hell 和 Promise

* 异步都是通过回调函数执行（）=>{}

###### event loop

**js是单线程，异步要基于回调来实现，event loop就是异步回调的实现原理。**

`eventloop`应用场景有异步(setTimeout、ajax)使用回调，DOM事件使用回调。

js从前到后一行一行执行

如果某一行执行报错则停止执行下面的代码执行

先把同步代码执行完，再执行异步

`call Stack`调用栈

`web APIs`浏览器定义的操作，DOMBOM等

`Event Loop`事件循环

`callback Queue`回调队列

```javascript
//示例
console.log('Hi');
 setTimeout(()=>{
     console.log('cb1')
 },5000);
$("#id").click((e)=>{
     console.log('cb1')
})
//其中$('#id').click会立即执行，将回调事件放入webAPIs中，当用户点击时候放入回调队列中，event loop进行循环，将队列中的事件放入执行栈中执行
console.log('Bye');
```

`console.log('Hi')`首先在调用栈执行代码，代码执行结果在`Browser console`打印结果，执行完清空调用栈

**`event loop`运行步骤**

1. `setTimeout` 在调用栈`call Stack`执行，将回调事件在`webAPI`定义添加记录一个定时器，

2. 执行完后清空调用栈`call stack`，

3. 在定时器时间到后放在事件回调队列`callback queue`中，

4. 同步代码执行完了之后，启动事件循环`eventloop`，去回调队列`callback queue`中寻找回调函数，放入调用栈`call stack`执行

`console.log('Bye')`首先在调用栈执行代码，代码执行结果在`Browser console`打印结果，执行完清空调用栈

* 请描述event loop（事件循环/事件轮询）的机制，可画图？

* ![1673492616586](/C:/Users/xiaoha/AppData/Roaming/Typora/typora-user-images/1673492616586.png)

  

###### promise进阶

* promise有哪三种状态，状态之间是如何转变的？

  ```javascript
  三种状态：准备中pending 成功resolved 失败rejectd
  pending-> resolved 成功
  pending->rejected 失败
  执行不可逆
  pending不会触发 then catch
  resolve会触发 then
  reject会触发 catch
  ```

  `then`和`catch`改变状态

  ```javascript
  const p1 = Promise.resolve().then(()=>{
      return 100
  })
  console.log('p1',p1)//resolve
  cosnt p2 = Promise.resolve().then(()=>{
      return new Error('err')
  })
  console.log('p2',p2)//reject
  p2.then(()=>{
      //不执行
  }).catch(()=>{
      //执行这里
  })
  
  const p3 =  Promise.reject('my Error');
  p3.catch((err)=>{
      console.error(err)
  })
  console.log('p3',p3);//resolved触发then回调
  
  const p4 = Promise.reject('err');
  p4.catch((err)=>{
      throw new Error(err)
  })
  console.log('p4',p4)//rejected触发catch回调
  //总结：1.then正常返回resolve,里面有报错则返回rejected 2.catch正常返回resolve，里面有报错则返回rejected
  ```

  

* 场景题-promise then 和catch的连接

  ![1673424336226](/C:/Users/xiaoha/AppData/Roaming/Typora/typora-user-images/1673424336226.png)

第一题：1 3

第二题：1 2 3

第三题：1 2

```javascript
//题目四
async function async1(){
    console.log('async start')//2
    await async2()
    console.log('async end')//5 await后面的相当于都是callback内容属于异步
}
async function async2(){
    console.log('async')//3
}
console.log('script start')//1
async1()
console.log('script end')//4
同步执行完后执行异步
```

###### 手写Promise构造函数,.then().catch()

```javascript
//myPromise
class MyPromise{
    state = 'pending' //状态："pending =>fulfilled、pending=>rejected"
    value = undefined //成功后的值
    reason = undefined //失败后的原因 

	resolveCallbacks = [] //pending状态下，存储成功的回调
	rejectdCallbacks = [] //ending状态下，存储失败的回调

    constructor(fn){
        super()//用于继承本次不需要使用
        const resloveHandler =(value)=>{
            if(this.state === 'pending'){
        this.state = 'fulfilled'     
        this.value = value
  		this.resolveCallbacks.forEach(fn=>fn(this.value))
               }
        }
        const rejectHandler =(reason)=>{
            if(this.state === 'pending'){
        this.state = 'rejected' 
        this.reason = reason
  		this.rejectedCallbacks.forEach(fn=>fn(this.reason))
               }
        }
        try{
     		fn(resloveHandler,rejectHandler)
        }catch(err){
            rejectHandler(err)
        }
    }
//实现then方法
	then(fn1,fn2){
        // 当pending状态下，fn1 fn2存储在callbacks中
        fn1 = typeof fn1 ===  'function' ? fn1 :(v)=>v
        fn2 = typeof fn2 ==='function' ? fn2 : (e)=>e
        
        if(this.state === 'pending'){
           //第一步返回一个Promise,不能立即执行，因为不知道是执行成功还是失败的状态，pending只有在变化的时候执行，不会立即执行则需要存储回调。
            const p1 = new MyPromise((resolve,reject)=>{
                this.resolveCallbacks.push(()=>{
                    //第二步返回一个回调执行也是返回promise,通过try
                    try{
                        //返回新结果Promise
                        const newValue = fn1(this.value)
                        resolve(newvalue)
                    }catch(err){
                        reject(err)
                    }
                    
                })
                this.rejectedCallbacks.push(()=>{
                    try{
                        //返回新的错误结果
                        const newReason = fn2(this.reason)
                        reject(newReason)
                    }catch(err){
                        reject(err)
                    }
                })
            })
           }
        //'fullfilled'成功的回调会立即执行
        if(this.state === 'fulfilled'){
            //第一步首先确定返回了一个p1实例
           const p1 = new MyPromise((resolve,reject)=>{
               //第二步通过try catch捕获报错信息
               try{
                   //第三步实现then((data)=>) 返回的新数据value但是是Promise类型，使用resolve执行成功方法
                   const newValue = fn1(this.value)
               resolve(newValue)
               }catch(error){
                   reject(error)
               }
           })
           return p1
           }
        //失败rejected需要立即执行
        if(this.state === 'rejected'{
           //第一步返回一个Promise类型数据
           const p1 = new MyPromise((resolve,reject)=>{
            //第二步通过try catch捕获
            try{
                //第三步将获取到的失败原因结果通过promise转换抛出调用reject返回
                const newReason = fn2(this.reason)
               reject(newReason)
            }catch(err){
                reject(err)
            }
        })
         return p1
           }
    }
//catch就是then的一个语法糖
	catch(fn){
        return this.then(null,fn)
    }
}


-----------------------------------------------------------------------------------------
//具体实际使用执行
const p1  = new MyPromise((resolve,reject)=>{
    resolve(100) //状态变为fullfilled
    reject(错误数据....) //状态变为rejected
    setTimeout(()=>{
        resolve(200)
    },500)
}) //500微秒后状态由pending变为fullfiled
console.log(p1)

p1().then((value)=>{
    
},(reason)=>{
    
})
```

###### 实现Promise.resolve和Promise.reject

```JavaScript
//接上MyPromise
MyPromise.resolve = (value)=>{
   return new MyPromise((resolve,reject)=>{
        resolve(value)
    })
}

MyPromise.reject = (reason)=>{
   return new MyPromise((resolve,reject)=>{
        reject(reason)
    })
}
```

###### 实现Promise.all

```javascript
MyPromise.all = (promiseList)=>{
   //第一步必须返回一个Promise，且需要返回PromiseArr结果数组
    let resultList = []
    let count = 0
    return new MyPromise((resolve,reject)=>{
        //遍历传入的Promise数据，若全部成功则返回Promise结果
        promiseList.map((p)=>{
            p.then((res)=>{
                resultList.push(res)
                //then执行则表示每成功一次则+1
                count++
                //判断PromiseList的长度等于执行then成功的长度一致则表示全部执行all
                if(promiseList?.length === count){
                    resolve(resultList)
                   }
            }).catch((err)=>{
                reject(err)
            })
        })
    })
}
```

###### 实现Promise.race

```javascript
MyPromise.race = (promiseList)=>{
    let resolveFlag = false
    //第一步返回Promise数据，当PromiseList中有成功的则就返回成功
    return new MyPromise((resolve,reject)=>{
        promiseList.forEach((p)=>{
            //查找到所有的数组中第一个成功的Promise实例
            p.then((res)=>{
              if(!resolveFlag){
                 resolve(res)
                 resolveFlag = true 
                 }
            }).catch((err)=>{
               reject(err)
            })
        })
    })
}
```

###### async/await

异步回调 callback hell

Promise then catch 链式调用，基于回调函数

async/await是同步语法，彻底消灭回调函数

**await必须由async包裹**

```javascript
(async function(){
    const img = await laodImg(src);
    console.log(img.width,img.height);
     const img1 = await laodImg(src1);
    console.log(img1.width,img1.height);
})()
```

###### async和await和promise的关系

* async/await消灭了异步回调的方法

* 但是和promise相辅相成

* 执行async函数，返回的永远都是promise对象

* await相当于Promise的then

* try...catch可以捕获异常，代替了promise中的catch

  ```javascript
  //执行async函数，返回的是promise对象
  async function fn1(){
      return 100
  }
  console.log(fn1())//promise
  fn1().then((data)=>{
      console.log(data)//100
  })
  //await相当于Promise的then
   (async function(){
    const p1 = Promise.resolve(100)
    const data = await p1
    console.log(data)//100
   })()
   (async function(){
    let data2 = await fn1()
    console.log(data2)//100
   })()
  //async/await中try catch相当于catch
  (async function(){
   const p1 = Promise.reject('err');
   try{
       let res = await p1
       console.log(res)
   }catch(err){
       console.log(err)
   }
  })()
  ```

  

![1673424292190](/C:/Users/xiaoha/AppData/Roaming/Typora/typora-user-images/1673424292190.png)

```
第一题：
100 promise
100
第二题：
start
'a' 100
'b' 200
error
await相当于then需要用try catch
```



![1673424381052](/C:/Users/xiaoha/AppData/Roaming/Typora/typora-user-images/1673424381052.png)

```
100
400
300
200
//微任务比宏任务先执行
```



![1673424402346](/C:/Users/xiaoha/AppData/Roaming/Typora/typora-user-images/1673424402346.png)

```javascript
解答：
script start 
async1 start
async2
promise1
script end
async1 end
promise2
setTimeout
//初始化promise时，传入的函数会立即被执行
//同步代码执行完，后event loop执行向回调队列找异步方法执行
//微任务
//尝试DOM渲染
//触发Event loop执行宏任务

```

第二遍解释：

```JavaScript
'script start'
'async start'
'async2'
'promise1' //初始化的Promise时传入的函数会立即执行 then后的回调是异步微任务（不立即执行）
'script end' //先执行同步任务后执行微任务: promise/async await 再执行宏任务setTimeOut
'async1 end' //await 后面的都作为回调内容 -微任务 （不立即执行）
'promise2'
'setTimeout'
```

![1718674426926](/C:/Users/xiaoha/AppData/Roaming/Typora/typora-user-images/1718674426926.png)

问题一：

```JavaScript
async fn函数为 promise函数，const a = fn() //则a为promise函数
await 相当于执行promise函数的fn().then(), const b = await fn() //则b为fn().then()结果为100
```

问题二：

```javascript
'start'
'a':100
'b':200 //其中await resolve为成功相当于.then执行则返回200
//await为执行.then操作，但是执行了await Promise.reject(300)，.then则不会执行失败reject操作返回，也不会执行后面的代码
```



###### 宏任务/微任务

* 什么事宏任务和微任务，两者有什么区别？

异步api的分类

**宏任务：setTimeout setInterval ajax  DOM 事件**

**微任务：promise,async/await**

**微任务执行时机比宏任务要早**

为什么执行早原因：

js是单线程的，和DOM渲染是共用一个线程

js要留一些时机给DOM渲染

![1675323110600](/C:/Users/xiaoha/AppData/Roaming/Typora/typora-user-images/1675323110600.png)

Promise执行时候要放入micro task queue微任务队列

setTimeout是在DOM渲染之后

微任务是ES6语法规定的

宏任务是由浏览器规定的

![1675323089838](/C:/Users/xiaoha/AppData/Roaming/Typora/typora-user-images/1675323089838.png)

#### DOM面试题

##### DOM的本质是什么

（ ducument object Model）文本对象模型

* DOM是哪种数据结构

  树（DOM树）

* DOM操作的常用API

  ```javascript
  const div= document.getElementById('div1')
  const list1= document.getElementsByClassName('container')//集合
  const list2= document.getElementsByTagName('div')//集合
  const list3= document.querySelectorAll('p')
  //集合
  document.createElement('li')
  ```

* attribute和property的区别

  1. property:修改对象属性，不会体现在html中
  2. attribute:修改html属性，会改变html结构
  3. 两者都会引起DOM重新渲染

  ```javascript
  const p1 = list3[0]
  //property:修改对象属性，不会体现在html中
  p1.style.width = '12px'
  p1.className = 'div1'
  //attribute:修改html属性，会改变html结构
  p.getAttribute('data-name')
  p1.setAttribute('data-name','imooc')
  p1.setAttribute('style','font-size:50px')
  
  //插入DOM节点，删除DOM节点
  const p1 = list3[0]
  const div1 = list2[0]
  div1.appendChild(p1)//插入新节点
  //等于现有节点使用appendChild则会移动节点
  div1.childNodes[0].nodeType/nodeName
  div1.removeChild(child[0])
  ```

* 一次性插入多个DOM，性能问题

  1. 避免频繁操作DOM
  2. 对DOM查询做缓存  
  3. 将频繁操作改为一次操作

  ```javascript
  //对DOM查询做缓存实现
  const listLength = document.getElemntById('p').length
  for(let i = 0 ;i<listLength;i++){
      ...
  }
  
  //频繁操作改为一次操作具体实现
  const list = document.getElementById('list')
  //创建文档片段
  const frag = document.createDocumentFragment()
  
  for(let i = 0;i<10;i++){
      const li = document.createElement('li')
      li.innerHtml = `list item ${i}`
      //先插入文档片段中
      flag.appendChild(li)
  }
  //都完成后在全部一起插入DOM中
  list.appendChild(frag)
  ```

#### BOM面试题

browser object model 浏览器对象操作模型

##### navigator

```javascript
const ua = navigator.userAgent //当前浏览器的信息
const isChrome  = ua.indexof('chrome') //ua就是浏览器信息简称
```

##### scrren

```javascript
screen.width
screen.height
```

##### loaction

```javascript
//地址信息
location.href //整个网址地址信息
location.protocal //http https
loaction.pathname //'/learn/199' 路径
loaction.search //?后面的内容
location.hash //#后面的内容
loaction.host //域名
```

##### history

```javascript
//路由前进后退信息
history.back() //后退
history.forword() //前进
```

#### 事件绑定和事件冒泡

##### 事件绑定

```javascript
const btnListener = (elem,action,fn)=>{
    elem.addEventListener(action,fn)
}
const btn1 = document.getElementByTagName('contain')[0]
陈(btn1,'click',(event)=>{
    //触发点击的元素
    console.log(event.target)
    //阻止默认事件,如链接跳转则可以阻止
    event.preventDefault()
    console.log('点击了一次')
})
```

##### 事件冒泡

阻止冒泡方法：`event.stopPropagation`

阻止默认事件：`event.preventDefault` 如：点击链接自动跳转等

```JavaScript
//触发子元素事件，则器子级的上级或者父级也能监听到该事件，
<body>
    <p id='p1'>1</p>
    <p>2</p>
    <p>3</p>
    <p>4</p>
</body>
const body = document.body
//此时点击p标签就会向上冒泡，则e.target显示p标签点击事件,body也触发点击事件
event.target(body,'click',(e)=>{
    console.log(e.target)
})
```

##### 事件代理(瀑布流)

解释：如子节点都需要监听，则可以代理监听父节点，通过触发子节点冒泡到父节属性判断操作

```javascript
//模拟瀑布流
const div3 = document.getElemntById('div')
const p = document.createElemnt('p')
btnListener(div3,'click',(e)=>{
    //阻止默默认链接点击事件
    e.preventDefault()
    if(e.target.nodeName !== 'A'){
       	div3.appendChild(p)
    }else{
           alert(e.target.innerHtml)
     }
})
```

* 编写一个通用的事件监听函数

  ```javascript
  const btnEventListener = (elem,action,selector,fn)=>{
      if(fn == null){
          fn = selector
          selector= null
      }
      elem.addEventListener(action,(event)=>{
         const target = event.target
          if(!selector){
             //非事件代理
              event.preventDefault
          	event.stopPropagation
              fn.call(target,event)
             }else{
             //事件代理
              if(target.matches(selector)){
                  fn.call(target,event)
              }  
              
          }
      })
  }
  ```

* 描述事件冒泡的流程

  ```javascript
  //1.基于DOM树形结构
  //2.事件会顺着触发元素向上冒泡
  //3.应用场景：代理
  //阻止冒泡的方法
  event.stopPropagation()
  ```

* 无限下拉的图片列表，如何监听每个图片的点击

  ```javascript
  1.通过事件代理
  2.通过event.target获取触发的元素节点
  3.通过event.target.matches判断是否匹配对应的节点触发
  ```

#### ajax

##### 手写简易的ajax

```javascript
const ajax = (url) => {
    return new Promise((resolve,reject)=>{
        const xhr = new XmlHttpRequest()
            xhr.open('GET',url,true)
        xhr.onreadystatechange = () => {
            if(xhr.readyState === 4){
                if(xhr.status === 200){
                    resolve(JSON.parse(xhr.responseText))
                   }else if(xhr,status === 404){
                       reject(new Error('404 not found'))
                   }
               
               }
        }
        xhr.send(null)
    })
}

ajax('http://localhost:8002').then((res)=>{
    console.log(res)
}).catch((error)->{
    console.log(error)
})


const ajax = (url) =>{
    return new Promise((resolve,reject)=>{
        let xhr = new XmlHttpRequest()
        xhr.open('GET'url,true)
        xhr.onreadystatechange = (res)=>{
            if(xhr.readyState === 4){
               if(xhr.status === 200){
                  resolve(JSON.parse(xhr.responeseText))
                  }
               }else if(xhe.status === 404){
                   reject(new Error('404'))
               }
        }
        xhr.send(null)
    })
}
```

##### 跨域的常用实现方式

如下几点：jsonp和CORS

* XMLHttpRequest

  ```javascript
  //手写简易的ajax
  //new一个实例
  const xhr = new XmlHttpRequest()
  //打开一个请求，true代表异步请求
  xhr.open('GET/POST','/api/url',true)
  //监听请求
  xhr.onreadystatechange = () =>{
      //4代表请求处理下载完成
      if(xhr.readystate === 4){
          //请求返回状态正常
          if(xhr.status === 200){
             alert(xhr.responseText())
             }
          //代表请求地址不正确
          if(xhr.status === 403){
             alert('404 noy found')
             }
         
         }
  }
  const postData = {
      id:3,
      planNumber:'PLN780000356',
  }
  xhr.send(null/postData)
  
  //readyState状态码
  0 尚未调用open方法
  1 open方法已经调用
  2 send方法已被调用，header已被接收
  3 login下载中，reponseText已有部分内容
  4 done下载完成
  //Status码
  200 表示成功处理请求 如200
  300 需要重定向，浏览器直接跳转，301 302 304
  4XX 客户端请求错误或者请求地址错误，如404 403
  5XX 服务器端请求错误
  ```

* 状态码

* 跨域：同源策略，跨域解决方案

  ```javascript
  //什么是跨域，同源策略
  ajax请求，浏览器要求当前网页和server必须同源(安全)
  同源：协议、域名、端口，三者必须一致
  前端:http://a.com:8080/; server:http://b.com/api/xxx
  特殊例子：
  img、script、link标签可以，图片、css、js无视同源策略
  //跨域
  所有的跨域都需要经过server端允许和配合
  未经server端允许就实现跨域，说明浏览器有漏洞，危险信号
  ```

##### JSONP

```javascript
script可绕过跨域限制
服务器可以任意动态拼接数据返回
所以<script>就可以获得跨域的数据，只要服务端返回
//localhost:8001
<script>
    window.callback = (data)=>{
    console.log(data)
}
</script>
<script src="http://localhost:8002/jsonp.js"></script>

//localhost:8002 jsonp.js
<script>
    callback({
    name:'xiaomei'
    sex:'女'
})
</script>

$.ajax({
    url:'localhost',
    dataType:'jsonp',
    jsonpCallback:'callback',
    success:(data)=>{
        console.log(data)
    }
})
//关键点：script可以实现跨域且server可以动态拼接任意数据返回
```

```javascript
const myPromiseAll = (promiseArr)=>{
    let count = 0
    let resArr = []
  return new Promise((reject,resolve)=>{
      promiseArr.map((p)=>{
          p.then((res)=>{
              count++
              resArr.push(res)
              if(count === promiseArr.length){
                 resolve(resArr)
                 }
          }).catch((err)=>{
              console.log(err)
          })
      })
  })
}

const myPromiseAll = (promiseArr)=>{
    let promiseFlag = true
    return new Promise((reject,resolve)=>{
        promiseArr.map((p)=>{
            p.then((res)=>{
                if(promiseFlag){
                   resolve(res)
                   promiseFlag = false
                   }
            }).catch((err)=>{
                console.log(err)
            })
        })
    })
    
}


```



##### CORS-服务器设置 http header

```javascript
node.js服务端
//第二个参数为允许跨域访问的地址，不建议直接写*
response.setHeader('Access-Control-Allow-Origin',"http://localhost:8011")
response.setHeader('Access-Control-Allow-Headers',"X-Request-With")
response.setHeader('Access-Control-Allow-Methods',"PUT,POST,GET,DELETE,OPTIONS")
//设置接收跨域的cookies
response.setHeader('Access-Control-Allow-Credentials','true')
```


* JQuery插件实现ajax

  ```javascript
  $.ajax({
      type:'GET',
      contentType:'application/json:charset=Utf-8'
      url:'',
      data: JSON.stringify(list),
      success:()=>{
          
      },
      error:()=>{
          
      }
  })
  ```

* fetch插件

  ```javascript
  fetch(url,{
      body:
      method:
  }).then(()=>{
      
  })
  ```

* axios

  ```javascript
  //支持http和浏览器及node.js
  axios.get/POST(url,{
      planNumberL:"1800000002"
  }).then((res)=>{
      console.log(res)
  }).catch((err)=>{
      console.log(err)
  })
  ```

#### 浏览器存储 cookie、 sessionStorage、localStorage

##### cookie

本身用于浏览器和server通讯，属于http请求的一部分，被借用到本地存储，可以用`document.cookie = 'a:100;b:300;c:300;'`来修改（key：valu格式）

* 存储大小，最大4KB
* http请求时需要发送到服务端增加请求数量
* 只能用document.cookie来修改

##### loacalStorage

`localStorage.setItem('a':100) localStorage.getItem('a')`

* HTML5专门为存储设计，最大5M
* API简单医用setItem、getItem
* 不会随着http请求发送出去
* 数据永久存储，除非代码或者浏览器手动删除

##### sessionStorage

* 如上三点

* 数据只存在于当前会话，浏览器关闭就清空

##### 之间区别

* 容量 4KB和5M
* 是否随着http请求发送出去
* 存储时间，一直存在还是页面关闭就清除
* API易用性 setItem或者getItem或者document.cookie = ''

#### http

http面试题

##### http常见的状态码statusCode

1. 状态码分类

* 1XX 服务器收到请求

* 2XX 请求成功，如200

* 3XX 重定向，如302

* 4XX 客户端错误，如404，请求地址不存在

* 5XX 服务端错误，如500

2. 常见状态码
   * 200成功
   * 301 永久重定向，(配合location，浏览器自动处理)
   * 302 临时重定向,（配合location ，浏览器自动处理）
   * 304 资源未被修改，资源是最新的，下次也不会返回
   * 404 请求地址不存在，资源未被找到
   * 403 没有权限
   * 500 服务器错误
   * 504 网关超时，第一台服务能通可能连接的第二台服务连接超时

3. 关于协议与规范
   * 就是一个约定
   * 要求统一执行
   * 不要违反规定，例如IE浏览器

##### http常见的header有哪些

requestHeaders

* Accept 浏览器可接收的数据格式 application/xml
* Accept-Encoding浏览器可接收的压缩算法，如gzip
* Accept-Language
* connection：keep-alive 一次TCP连接重复使用
* cookie
* Host 请求域名网址
* User-Agent（简称UA）浏览器信息，浏览器版本等
* Content-type发送数据的格式，appliction/json text/html image/png
* Content-length 返回数据的大小，多少字节
* Content-Encoding 返回数据的压缩算法
* Cache-Control 、Expires、last-Modified If-Modified-Since、Etag、If-None-Match缓存相关

responseHeaders

* set-Cookie 服务端改cookie

1. http methods

   * 传统的methods

     get获取服务器的数据，post向服务器提交数据，简单网页功能操作

   * 现在的methods

     get获取数据，post新建数据 patch(补丁)/put更新数据、delete删除数据

#### GET POST PUT DELETE

GET:请求数据，不会新增和更改数据

POST：发送请求新增，会更改数据种类及数量

PUT：修改数据，更新数据格式

DELETE：删除数据

##### 什么是Restful API

* 一种新的API设计方法（早已推广使用）

* 传统API设计：把每个URL当成一个功能

* **RestfulAPI设计，把每个URL当做一个唯一的资源，或者唯一的ID**

  * 尽量不用url参数

    ```javascript
    //传统
    /api/list?pageIndex=2
    //Restful
    /api/list/2
    ```

  * 用method表示操作类型

    ```javascript
    //传统
    post请求 /api/create-blog
    get请求 /api/get-blog?id=100
    //Restful
    post请求 /api/blog
    patch请求 /api/blog/100
    get请求 /api/blog/100
    ```

##### 描述一下http的缓存机制（重要）

1. 关于缓存的介绍

   * 什么是缓存？

     未访问过的地址，本地没有任何信息，把没有必要重新获取的信息缓存下来

   * 为什么需要缓存

     将提高浏览器加载速度，减少网络请求体积等

   * 哪些资源可以被缓存？

     静态资源（js css img）

2. http缓存策略（强制缓存+协商缓存）

   * **强制缓存**

     请求服务器中服务端判断控制部分资源（js css image）可以本地缓存就添加cache-control，控制缓存过期

     **Cathe-Control**

     * Response Headers中

     * 控制强制缓存的逻辑

     * 例如 Cathe-Control:max-age = 3153600(单位是秒)一年时间

       disk cache本地缓存

     * max-age、no-cathe（不用本地强制缓存，根据服务端处理）、no-store（不用本地缓存且不用服务端缓存）

     * private 只允许最终用户缓存

     * public 允许中间路由代理缓存

     **Expires**

     * 也在 Response Header中
     * 同为控制缓存过期
     * 已被Cathe-Control代替

     ![1720182506029](/C:/Users/xiaoha/AppData/Roaming/Typora/typora-user-images/1720182506029.png)

     ![1720182699260](/C:/Users/xiaoha/AppData/Roaming/Typora/typora-user-images/1720182699260.png)

   * **协商缓存（对比缓存）**

     * 服务器端缓存策略

     * 服务端判断客户端资源，是否和服务端资源一样

     * 一致则返回304（资源返回一致不需要重新请求资源返回），否则返回200和最新的资源

     * 资源标识

       * 在Response-Header中，有两种
       * last-Modefiedz资源的最后修改时间
       * Etag资源的唯一标识（一个字符串）
       * 会优先使用Etag

       ![1720183907713](C:\Users\xiaoha\AppData\Roaming\Typora\typora-user-images\1720183907713.png)

       ![1720184103584](C:\Users\xiaoha\AppData\Roaming\Typora\typora-user-images\1720184103584.png)

       ![1720184359128](C:\Users\xiaoha\AppData\Roaming\Typora\typora-user-images\1720184359128.png)

3. 刷新操作方法，对缓存的影响

   * 正常操作：地址数据url，跳转连接，前进后退

   * 手动刷新F5，点击舒心按钮，右键菜单刷新

   * 强制刷新：ctrl+F5（清除缓存的刷新）

     正常操作：强制缓存有效，协商缓存有效

     手动刷新：强制缓存失效，协商缓存有效

     强制刷新：强制缓存失效，协商缓存失效

##### https

* http和https的区别

  * http是明文传输，敏感信息容易被中间劫持
  * http = http + 加密，劫持了也无法解密
  * 现在浏览器已开始强制https协议（非https会提示非安全网址）

* 加密方式：对称加密，非对称加密

  * 对称加密：一个key负责加密和解密

  * 非对称加密：一对key，用A来加密则B来解密

  * https同时用到这两种解密方式

    ![1720281205406](C:\Users\xiaoha\AppData\Roaming\Typora\typora-user-images\1720281205406.png)

    ![1720281323207](C:\Users\xiaoha\AppData\Roaming\Typora\typora-user-images\1720281323207.png)

* https证书

  * 中间人攻击（劫持pubkey和key做为替换真实的）
  * 使用第三方证书（慎用免费，不合规的证书）
  * 浏览器校验证书

#### webpack

##### 开发环境

* git

  * 工具：github、企业版码云

  * 自己搭建的内网git服务

  * 常用命令

    ```javascript
    git clone
    git add
    git status
    git log
    git checkout XXX
    git commit
    git push
    git pull
    git branch
    git checkout
    git merge
    git show id码
    ```

* chrome调试工具

  * 样式调整
  * application 本地存储 localStorage sessionStorage
  * netWork 请求url接口发送 ，资源加载情况和状态码
  * sources dev本地源码文件，debugger编写再

* 抓包

  * 移动端h5网页，查看网络请求，需要用工具抓包
  * windows一般使用fiddler
  * mac OS一般使用chasrles
  * 手机和电脑必须同一个局域网
  * 将手机代理到电脑上
  * 手机浏览网页进行抓包
  * 查看网络请求
  * 网址代理
  * https
  * 下去需要使用fiddler实现手机接口抓包

* webpack babel

  * ES6模块话，浏览器暂不支持

  * ES6语法，浏览器并不完全支持

  * 压缩代码，整合代码，以让网页加载更快

    安装webpack
  ```javascript
  npm init -y
  npm install webpack-cli -D
  development//不会被压缩代码
  production//代码压缩
  
  //打包演示代码
  module.exports ={
   mode:'development', //production
   entry： path.join(__dirname,'src','index.js'),
   output:{
   filename:'bundle.js',
   pathLpath.join(__dirname,'dist')
   }
  }
  ```

* linux常用命令

##### 运行环境

运行环境即浏览器（server端有node.js）

下载网页代码，渲染出页面，期间会执行若干JS

网页加载过程

##### 1.从输入url到渲染到页面的整个过程

**资源的形式**：1. html代码 2.图片、视频 3. js css

**加载过程：**

1.DNS解析：域名->IP地址 

2.浏览器根据IP地址向服务器发起http请求（ajax请求三次握手）

3.服务器处理http请求，并返回给浏览器

**渲染过程：**

1. 根据HTML代码生成DOMTree 
2. 根据CSS代码生成CSSOM 
3. 将DOMTree和CSSOM整合形成 Render Tree 
4. 根据Render Tree渲染页面 5.遇到<script>则暂停渲染，优先加载js文件代码，完成再继续 （script中可能会更改html结构或者样式）
5. 直至把render Tree渲染完成

##### 2.为何把CSS建议放在header

从上至下渲染，若未先转换CSSOM，渲染界面时会在进行加载CSSOM，则样式会加载延迟

##### 3.为什么把<script>标签放在代码最后

放在前面会出现暂停卡顿问题

##### 4.window.onload和DOMContentLoaded的区别

window.onload是监听浏览器加载html js css包括图片和视频等文件后才会执行

window.DOMContentLoaded则是在监听浏览器加载完html js css后就执行

##### 性能优化

性能优化原则

* 多使用内存、缓存或者其他方法
* 减少CPU计算量，减少网络加载耗时
* 适用于所有编程的性能优化——空间换时间

如何入手

1. 让加载更快
   * 减少资源体积：压缩代码 (webpack)
   
     <img src="C:\Users\xiaoha\AppData\Roaming\Typora\typora-user-images\1724139382532.png" alt="1724139382532" style="zoom:33%;" />
   
   * 减少访问次数：合并代码(雪碧图，多文件合并代码) 、SSR服务器端渲染（
   
     服务器端渲染：将网页和数据一起加载，一起渲染
   
     非SSR（前端端分离）：先加载网页渲染，再加载数据，在渲染数据
   
     ）、缓存
   
     <img src="C:\Users\xiaoha\AppData\Roaming\Typora\typora-user-images\1724139408465.png" alt="1724139408465" style="zoom:50%;" />
   
     
   
     * 静态资源加载hash后缀，根据文件内容计算hash
     * 文件内容不变，则hash不变，则url不变
     * url和文件不变，则会自动触发http缓存机制，返回304（资源未改变直接取缓存）
   
   * 使用更快的网络：CDN（专门做静态网络文件服务的）
   
     <img src="C:\Users\xiaoha\AppData\Roaming\Typora\typora-user-images\1724139870284.png" alt="1724139870284" style="zoom:50%;" />
2. 让渲染更快
   * css放在head JS放在body最下面
   
   * 尽早开始执行JS，用DOMContentLoaded触发
   
   * 懒加载（图片懒加载，上划加载更多）
   
   * 对DOM查询进行缓存
   
     ![1724140784971](C:\Users\xiaoha\AppData\Roaming\Typora\typora-user-images\1724140784971.png)
   
   * 频繁DOM操作，合并到一起插入到DOM结构
   
     ![1724140846855](C:\Users\xiaoha\AppData\Roaming\Typora\typora-user-images\1724140846855.png)
   
   * 节流throttle 防抖debonce

###### 防抖

频繁操作永远取最后一次操作触发

用户输入结束或者暂停，才会触发Change事件

```javascript
debounce
const input1 = document.getElementByTagName('input')
const fn =()=>{
    console.log(input.value)
}
const debunce = (fn,delay=500)=>{
    //timer是闭包中的变量 （闭包：函数作为参数传入，或者返回一个函数）
    let timer = null
    //如果timer存在就清除上一个定时器，永远执行最后一个定时器
    return () => {
         if(timer){
        	clearTimeout(timer)
    	}
        //设置定时器
        timer = setTimeout(()=>{
            //执行需要防抖的方法
            fn.apply(this,arguments)
            //清除最后一次执行的定时器timer，便于下次执行直接调用setTimout方法
            timer = null
        },delay)
    }
   
}

input1.addEventlistener('keyup',debunce(fn,700))
```

###### 节流

频繁操作保持一个频率触发

* 拖拽一个元素时，要随时拿到元素拖拽的位置
* 直接使用drag事件，则会频繁触发，很容易导致卡顿
* 节流：无论拖拽速度多块，都会每隔100ms触发一次

```html
<div dragable='true' id='div1' style=“width:50px;height:50px”></div>
```

```javascript
throttle
//获取DOM节点元素
const div1 = document.getElementById('div1')

//节流，按照一定delay频率触发方法
const throttle = (fn，delay=100)=>{
    //闭包变量，防止变量污染
    let timer = null
    //在定时器中的函数未触发时，不执行下一次方法
    return (...args)=>{
        if(timer){
           return
           }
        timer = setTimeout(()=>{
            //将外部的event也就是args通过aplly返回给函数调用
            fn.apply(this,args)
            timer = null
        },delay)
    }
    
}

//监听元素拖拽属性
div.addEventListener('drag',throttle(function(event){
    //这里的event是传给throttle的return中的回调函数。则需要使用apply将arguments传入
    console.log(event.offsetX,event.offsetY)
},200))
```



###### 图片懒加载

示例：

```javascript
<img id='Img1' src='preview,png' data-realsrc ="abc.png"/>
<script type= "text/javascript" >
    const img1 = document.getElementById('Img1')
//添加监听，当图片滚动到距离屏幕顶部距离多少时候才将剩下的图片返回
img1.addEventListen('scroll',()=>{
//
    console.log(img1.offsetX,img1.offsetY)
    img1.src = img1.getAttribute('data-realsrc')
})s
    </script>

```

##### 安全

* 常见的web前端攻击方式有哪些

  * XSS跨站请求攻击

    * 一个博客网站发表一个博客，其中嵌入script脚本

    * 脚本内容：获取对方cookies，发送到的服务器中（服务器配合跨域）

    * 发布这篇博客，有人查看，我就可以获取访问者的cookies

      ```javascript
      <script>alert(document.cookies)</script>
      &lt;script&gt;alert(document.cookies);&lt;/script&gt;
      //预防xss攻击
      替换特殊字符，如<变为&lt;>变为&gt;
      <script>变为&lt;script&gt;直接显示，而不会作为脚本执行
      前后端都进行替换
      使用XSS工具
      ```

  * XSRF跨站请求伪造

    * 商品id 100

    * 付费接口是：xxx.com/pay?id=100,但没有任何验证

    * 攻击：id200

    * 发送电子邮件

    * 邮件正文隐藏着<img src=xxx.com/pa?is=200/>

    * 一查看邮件，就帮忙购买了id 200商品

      预防XSRF攻击：

      * 使用post接口（跨域麻烦）
      * 增加验证，如密码，短信验证，指纹等

#### 74.['1','2','3'].map(parseInt)结果是什么？为什么

map的callback回调方法里面第一个参数是当前currentItem当前那条数据和index数据所在的下标

因此计算：

```javascript
parseInt(string, radix)//接收两个参数，第一个表示被处理的值（字符串），第二个表示为解析时的基数

parseInt('1','0') //1   parseInt第二个参数代表基数，0及10等表示十进制，计算后则为1

parseInt('2','1')//NaN  parseInt第二个参数代表基数，1表示一进制，一进制的数不能超过2则为NaN

parseInt('3','2')//NaN  parseInt第二个参数代表基数，2表示二进制，二进制数不能超过3为NaN

最终结果为：[1,NaN,NaN]
```

#### 75.为什么不能在条件语句中使用hooks？

Hook的调用都对应一个全局的index索引，通过索引去运行当前组件currentComponent上的_hooks数组中查找保存的值，也就是Hook返回的[state,useState]

(简单来说就是Hook的调用都是通过_hooks数组的下标按照顺序执行，若有一条是判断后才决定是否执行，那么Hook执行的顺序就被破坏打乱了，会造成渲染混乱)

[为什么不能在条件语句中使用Hook]: https://juejin.cn/post/6939766434159394830

#### 76.数据结构与算法

二分查找法：将所有的数据集合进行排序，确定需要查找的数据也就是输入数据，在当前这串数据中间项的前面还是后面，若在中间项后面，则直接

#### 77.TypeScript中有哪些变量申明方式？

1. let声明变量

   ```typescript
   let money:number = 0
   ```

2. const 声明变量

   ```typescript
   const name:string ='yangjing'
   ```

3. var 声明变量

   ```typescript
   var name:string ='hanjingwen'
   ```

4. 函数作用域内声明

   ```javascript
   function add(){
      let myName:string = 'xiaoha'
   }
   ```

5. 函数参数声请

   ```typescript
   function getMoney(name:string,age:number){
       console.log(name,age)
   }
   ```

6. interface接口声明

   ```typescript
   interface person(){
      name:string,
      age:number,
      onChange:()=>void
   }
   let people:person={name:'hanjingwen',age:20}
   ```

7. 数组或对象限定声明

   ```typescript
   const arr:number[]=[1,2,3]
   const obj:{name:string,age:number}={name:'hanjingwen',age:20}
   ```

8. 使用class类名声明

   ```typescript
   class animal{
       constructor(public name:string,public age:number){
           console.log(name,age)
       }
   }
   ```

#### 78.将cookies的时间设置为0，会发生什么？

```javascript
//有三种数据存储的方法，cookies sessionStorage localStorage
其中cookies是通过服务端设置的存储方法，随着每次接口的请求，在请求头中携带cookies，大小一般是5KB左右
若将cookies的生效时间设置为0的话，就会和sessionStorage一样在浏览器关闭时候销毁
其中sessionStorage是存储在浏览器中，大小5M左右，通过前端存储，在浏览器关闭时候销毁
其中localStorage也是存储在浏览器中，大小5M左右，通过前端存储，永久存储，即使在浏览关闭的时候还是存在
```

#### 79.useMemo和useCallBack两个hooks有什么区别？

```javascript
//useMemo有两个参数，第一个参数是回调函数处理数据并返回值，第二个参数是依赖数组，若依赖数组中的数据发生变化，则会执行回调函数中的方法处理数据返回并重新渲染界面，若没有变更则直接获取旧数据值返回，防止多次更新计算数据值返回导致不必要的渲染。
const cloumn = useMemo(()=>{
    let cloumn:any[]=[{age:15},{age:19},{age:18}].filter(()=>{v?.age>18})
    return cloumn
},[dep])
//useCallBack有两个参数，第一个参数是回调函数，第二参数是依赖数值，依赖数组发生改变时候，将会创建一个新的的回调函数方法，未改变的则会复用之前的回调函数方法，减少多次创建新函数。
const changeListen = useCallBack(()=>{
    ...
},[dep])
总结区别：
useMemo主要是用于缓存回调函数返回的数据值，适用于任何缓存数据值的场景
useCallBack 主要是缓存回调函数，适用于需要传递给子组件的事件处理函数，避免不必要的多次渲染
```

#### 80.树转转数组，数组转树

```javascript
//递归实现树转数组，扁平化
const faltTreeData =(treeData,newData)=>{
    treeData?.map((v)=>{
        if(v?.children!==[]){
           faltTreeData(v?.children,newData)
           }
        newData.push(v)
    })
    return treeData
}
faltTreeData(树数据，初始值)
//数组转成对应的树
const reBackTree=(flatData)=>{
    //第一步将数据中的children清空防止重复添加
    flatData?.forEach((v)=> v.children=[])
    //第二步将对应的id的数据
    let map = {}
    flatData?.forEach((v)=>map[v?.id]=v)
    let reBackArr =[]
    flatData?.forEach((v)=>{
        const parent = map[v?.pid]
        if(parent){
            parent.children.push(v)
        }
        reBackArr.push(v)
    })
}
```

递归查找树

```javascript
    let arr = [
         {id: 1, name: '部门1', pid: 0},
        {id: 2, name: '部门2', pid: 1},
        {id: 3, name: '部门3', pid: 1},
        {id: 4, name: '部门4', pid: 3},
        {id: 5, name: '部门5', pid: 4},
    ]
    
    const getChild = (data,result,pid)=>{
        data.map((v)=>{
            if(v?.pid === pid){
               const newItem = {...v,children:[]}
               result.push(newItem)
        getChild(data,newItem.children,v?.id)
               }
        })
        
    }
    
    const dataToTree = (data)=>{
        let result = []
        getChild(data,result,pid)
        return result
    }
    
    
   const treeToData = (arr,tree)=>{
        tree?.map((v)=>{
            if(v?.children != null && v?.children != []){
               	treeToData(arr,v?.children)
               }
                arr.push(v)
        })
    }
       
        let arr = [
         {id: 1, name: '部门1', pid: 0},
        {id: 2, name: '部门2', pid: 1},
        {id: 3, name: '部门3', pid: 1},
        {id: 4, name: '部门4', pid: 3},
        {id: 5, name: '部门5', pid: 4},
        {id: 6, name: '部门5', pid: 8},
    ]
       
    const dataToTree = (arr)=>{
        let tree = []
        let map = {}
      let newArr =  arr.map((v)=>({...v,children:[]}))
        newArr.map((v)=>{
            map[v?.id]=v
        })
        newArr?.map((v)=>{
            if(map[v.pid] != null){
               	map[v.pid].children.push(v)
               }else{
                tree.push(v)  
               }
        })
        return tree
    }
```





#### 81.addEventListener监听的第三个参数

`addEventListener`有三个参数

[^参数一 'click']: 各种Dom事件类型比如click等
[^参数二 function]: 函数，监听该事件触发后执行的函数方法
[^参数三 布尔值]: 不传默认为false表示该事件为事件冒泡，true表示该监听为事件捕获。

```javascript
const Btn = document.getElemntByClassName('button')
Btn.addEventListener('click',(event)=>{
    console.log(event,'出发的事件')
},true)
```

#### 82.避免JavaScript中的this指向混乱？

* 使用箭头函数，箭头函数能够向上查找最外部的this
* 使用 .bind()、.call()、或者.apply()方法绑定函数的this
* 使用闭包将引用的this缓存起来
* 在方法调用时候确保上下文正确

#### 83.如何防止按钮多次点击

1.编写防抖函数，在一定时间内触发一次，再次触发则重新计时

2.设置遮罩层，loading状态

3.如果使用button标签按钮，可以使用disable属性设置置灰

4.input禁止输入使用css样式`pointer-events:none cursor:not-allowed`

#### 84.不会冒泡的事件

1. focus
2. blur
3. focusin
4. focuout
5. load
6. unload
7. stop
8. scroll

#### 85.手写Reducer

```react
Array.prototype.reduce = fuction(){
    const arr = this;
    let total = arr[0];
    for(let i = 1; i< arr.length; i++){
      total = cb(total,arr[i],i,arr);
    }
     return total;
}
```

#### reduce用法

```javascript
//数组求和
const arr = [0,20,30,40,50,60];
arr.reduce((sum,currentVal,index,arr)=>sum+currentVal,0)

//查询数组中重复的值出现的个数
const arr1 =[10,20,30,40,50,50,60,10,10];
arr.reduce((count,currentVal,index,arr)=>currentVal === 10 ? count+1 : count,0)
//拼接字符串
const arr =[
    {name:'张三'，age:20},
    {name:'张三'，age:20},
    {name:'张三'，age:20},
];
arr.reduce((val,curentVal)=>{
    return `${val}${curentVal['name']}-${curentVal['age']}\n}`
},'')
```

#### 86.去重

```javascript
const unique = (arr)=>{
    return arr.filter((item,index,array)=>{
        return array.indexOf(item) === index
    })
}
```

#### 87.查找对应值

```javascript
 const A = [1, 2, 3];
        const B = [4, 5, 6];
        const C = [7, 8, 9];
        function test(num) {
            let newArr = A.concat(B).concat(C)
            let newObj = { 'A': A, 'B': B, 'C': C }
            for (x in newObj) {
                for (let i = 0; i < newObj[x].length; i++) {
                    if (newObj[x].includes(num)) {
                        return x
                    }
                }
            }
        }
        test(1)
        console.log(test(8))
```

#### 86.BFC

官方解释：BFC简称就是block Formatting Contexts(块级格式化上下文) W3C CSS2.1规范中的一个概念，页面中的一块渲染区域，并且有自己的一套渲染规则，决定子元素将如何定位，以及和其他元素喝的关系和作用

解决特殊场景下的样式

1. div盒子，子级盒子元素浮动，就会脱流，则外部父级盒子高度坍塌 解决：父级盒子使用overflow：auto或者hidden
2. 同一个BFC，两个div盒子上下排列，设置同一个margin，上下外边距会发生折叠，不是两个margin的距离 解决：两个盒子分别使用不同的BFC盒子包裹起来，避免外边距重叠，将其放在不同的BFC容器中

BFC是一个独立不干扰外界也不受外界干扰的盒子

```html
.container{
    overflow:auto
}
div{
    width:10px
    height:10px
    margin:100px
}
<div>
    <container> 
        <div></div>
    </container>
     <container> 
         <div></div>
    </container>
</div>

parent{
    width:100%
    height:100px
    overflow:auto
}

child{
    width:40px;
    height:40px'
    float:'left'
}
<parent>
    <child></child>
</parent>
```

#### 87.dispaly有哪些属性

```css
display:none 
display:inline 
display:inline-block
display:block
display:inherit 从父级继承的样式
display:table 元素作为表格 
display:table-cell 预算作为表格单元格显示td th
display:table-row 元素作为表格行显示 tr
display:list-item 元素作为列表显示
display:flex
```

#### 88.flex弹性盒子布局，实现排序转换

```css
div{
    display:flex
    flex-warp:no-warp
    flex-deriction:row/column //设置主轴方向
    row|column|row-reserve|column-reserve
    justify-content: center  //主轴排列样式
    align-item:center //副轴排列样式
    palce-content
        
}
```

#### 89.for...in和for...of的区别

**`for`循环**遍历数组等拥有`interator`接口的对象

**`for(key in object){}`**属于js中的循环结构，**`for...in`**可以循环遍历对象

* `for in`比遍历数组会存在顺序不定的问题
* `for in`遍历的`key`是该对象的`key`
* 遍历次数等于该对象的成员数
* 用于可枚举数据，如对象。数组、字符串

**`for(variable of iterable){}` **for...of用于循环遍历可迭代对象（`Array Map Set String `）

* `for...of` 循环返回`variable`是可迭代对象的元素值，类型即对应的值类型
* `break和return`可以终止循环，`continue`终止该循环继续下一个循环
* 用于迭代数据，如数组、字符串、`Map`、`Set`

**`forEach`循环**（数组中独有）

`Array.forEach((currentValue,index,oldArray)=>{})`

`forEach`会改变原数组，在`callback`回调中使用`return break continue`不生效

**`Array.reduce((prev,current,index,_arr)=>{})`**循环遍历非空数组，若遍历空数组则会报错

* prev表示当前数据前一轮循环的返回值，首次取该数组下标为0的值
* current从数组下标为1开始遍历，首次取该数组下标为1的值

* 主要用于数组中数据的累加或者累减，还可获取数组中的最大值

* 遍历空数组会报错


#### 90.git的常用指令

```
git rebase //变基，将会移动提交至另一个分支 会重写commit history
git merge //合并代码，产生一个新的commit提交
    例子：git checkout feature //本地切换到需要被合并的分支
    git pull 拉取最新代码
    git commit 提交
    git push 推送（先进行提交再进行推送）
    git merge master//master=>feature
git cherry-pick 提交码，单独的提交合并码
git revert  //回退到当前提交码的上一个提交版本代码，提交一个相反的提交（创建一个新的提交）
git reset  //本地回退到git提交历史指定版本（可能会删除掉原本的提交）
git clone  //克隆git代码地址
git checkout //切换本地分支
git fetch  //获取到当前所有分支
git branth //查看当前分支目录
git config --global user.name //设置全局的git用户名
git config --global user.email //设置全局邮件地址
git stash //暂存提交
git remote -v //查看远程仓库地址
```

#### 91.改变this的指向有哪几种方法

```javascript
function fun1(){
    
}
fun1.call(this,{})//第二个参数是对象
fun1.apply(Math,arr) //第二个参数是数组
const arr = [1,2,3,4,5,6]
例子：const max = Math.Max.apply(Math,arr)
```

#### 92.实现promise.all

```javascript
Promise.MyAll = function(promises){
    let arr = []
    let count = 0
    return new Promise((resolve,reject)=>{
        promises.map((item,index)=>{
           Promise.resolve(item).then((res)=>{
                arr[index] = res
               	count += 1 
               if(count === promises.length){
                  resolve(arr)
                  }
           }).catch(reject)
        })
    })
    
}
```

#### 93.new一个对象时候会做些什么

1. 创建一个新的空对象
2. 将空对象的`__proto__`指向构造函数的`prototype`
3. 执行构造函数，并将新创建的空对象绑定为构造函数的this对象
4. 如果构造函数有返回一个对象，则返回这个对象，否则返回新创建的对象

#### 94.数组常用方法

**改变原数组：**

1. `push()`在尾部添加数据，类似于压栈（入队），会改变原数组
2. `pop()`在尾部删除一条数据，类似于出栈，会改变原数组
3. `unshift()`在头部压入数据，类似于入队，会改变原数组
4. `shift()`在头部弹出数据，出队，其中`push()`(入队)和`shift()`（出队），模拟常见数据结构：队列
5. `reverse()`翻转原数组，并返回已完成翻转的数组，原数组改变
6. `splice()`返回截取的数组，`splice(start,deleteCount,item1,item2...) [start,deleteCount]`
   * deleteCount若为0，则表示不删除元素，从start位置开始添加元素到原数组中
   * 返回值由被删除的元素组成数组，如果只删除一个元素，则返回一个元素组成的数组，没有删除元素则返回空数组
   * 此方法会改变原数组，数组长度会发生变化
7. `sort()`排序，对数组的元素进行排序，返回排序后的数组，改变原数组

**不改变原数组**

1. `concat()`在当前数组尾部传入的数组，返回一个新数组，原数组不改变
2. `indexOf()`在当前数组中寻找该值，并返回其下标，找不到就返回`-1`,原数组不改变
3. `includes()`在当前数组中寻找该值，找到返回`true`,找不到则返回`false`
4. `join()`将数组转化成字符串，并返回该该字符串，原数组不变
5. `slice()`返回截取的部分数据，`slice(start,end) [start,end)`，包括起下标的数据，不包含止下标的数据，原数组不改变
6. `toString()`将数组转化成字符串并用逗号隔开，原数组不改变 
7. `map()`遍历数组返回一个深拷贝新的数组，不改变原数组
8. `filter()`遍历数组，return出符合条件的数据，不改变原数组
9. `some()`遍历数据是否存在一条数据满足条件，找到一个就停止,返回`true`,不存在任何一条满足就返回`false`
10. `every()`遍历每一项数据是否满足条件，每一项都满足提条件则返回`true`否则返回`false`
11. `reduce()/reduceRight()`，其中`reduce`从左到右将数组元素做叠加处理，返回一个值，`reduceRight()`从右到左
12. `Object.keys(obj)`遍历对象的属性，返回一个数组，该数组成员都是该对象自身的属性名也就是`keys`,且只返回可枚举的属性
13. `Object.getOwnPropertyNames(obj)`遍历对象的属性，返回一个数组，该数组成员都是改对象自身的属性值，但可返回不可枚举属性

#### 95.字符串常用方法

1. `charAt()`返回字符串指定索引下边index处字符

2. `concat()`返回一个合并拼接两个或两个以上字符串，原字符串不变

3. `indexOf()`返回一个字符在字符串中首次出现的位置，`lastIndexOf`返回一个字符在字符串中最后一次出现的位置。

4. `slice()`提取字符串的片段，并把提取的字符串做为新的字符串返回，原字符串不变。 

5. `split()`使用指定的分隔符将字符串拆分为多个子字符串数组并返回，原字符串不变。

6. `substr()`返回截取的字符串片段,`substr(start,strLong)`

7. `substring`返回截取的字符串片段，`substring(start,end) [start,end)`

8. `match()`返回保函该搜素偶结果的数组，在字符串中检索指定的值，或找到一个或多个正则表达式匹配。

9. `replace()`接收两个参数,`(需要替换掉的字符/正则的匹配规则，需要替换进去的字符)`

   ```javascript
   //替换去掉字符串中的空格及分号
   value.replace(/\s/g,''/).replace(/;/g,'')
   ```

10. `search()`在目标字符串中搜索与正则规则匹配的字符，若搜索到，则返回第一个匹配项在目标字符串中的位置，没有搜索到则返回`-1`

11. `toLowerCase()`把字母转换成小写

12. `toUpperCase()`把字母转换成大写

13. `includes(),startsWith(),endsWith()`

14. `repeat()`返回一个新的字符串对象，新字符串等于重复指定次数的原始字符串。

#### 96. 常用遍历方法&高阶函数

1. `for()` 循环，用于遍历数组及字符串
2. `while()/do while()`
3. `forEach()` 会更改原数组，`return`无法终止循环，也不支持`continue`和`break`
4. `for...in`主要用于遍历`Object`对象，遍历值为key，且遍历数组时可能顺序不定问题
5. `for...of`  用于遍历有`Iterable`接口的`Array`，遍历值为`value`，可以使用`return`及`break`终止循环

#### 97.不支持终止循环的方法有哪些

`forEach、map、filter`

#### 98.算法时间&空间复杂度

* O(n^2):表示两层循环（循环嵌套）
* O(nlogn):快速排序（循环+二分查询）
* O(n):表示一层循环
* O(logn):二分查询

#### 99.八大数据结构的JS实现

1. 栈：后进先出

   ```javascript
   let arr = []
   arr.push('1')
   arr.push('2')
   arr.pop('2')
   
   /**
    * @param {string} 解题栈
    * @return {boolean}
    */
   var isValid = function(s) {
      let arr = s.split('')
      if(arr.length % 2 > 0){
       return false
      }
      for(let i= 0;i<arr.length;i++){
       if(arr[i]){
   
       }
      }
   };
   ```

2. 队列：先进先出

   ```javascript
   let arr = []
   arr.push('1')
   arr.push('2')
   arr.Shift('1')
   ```

3. 链表：是多元素组成的列表，元素存储不连续，用`next`指针连在一起。`javaScript`中没有`链表`,但是可以用`Object`模拟链表

4. 集合：集合是一个无序且唯一的数据结构。ES6中有集合`Set`集合常用操作：去重、判断某元素是否在集合中，求交集

5. 字典（哈希）：字典也是一种存储唯一值的数据结构，但是它以键值对的形式存储，ES6中的字典名为`Map`

6. 树：`DOM`、树、级联选择、树形控件

#### 100.不会冒泡的事件

​	`focus、blur、focusin、focusout、load、stop、scroll、mouseenter`

#### 101.`MessageChannel`是什么，有什么使用场景

`MessageChnanel`是一个`JavaScript API`,用于两个独立的执行环境之间建立双向通信的通道。

使用场景包括：

1. `web Workers`通信
2. 不同浏览上下文（browsing）之间通信
3. `shareWorker`通信
4. 服务端与客户端之间通信
5. 异步任务处理

#### 102.async和await实现原理

由于`javaScript`是单线程执行模型，因此必须支持异步编程才能提高运行效率。异步编程的语法目标是让一步过程写起来像是同步过程

#### 103.解决var [a,b] ={a:'1',b:'2'}

因为对象不存在iterator接口，则不支持遍历，将传入的对象添加iterator接口编写回调方法`for...in`支持对象遍历处理数据

#### 104.强缓存、协商缓存等

强制缓存：指浏览器首先向服务器发出请求，若这是首次请求数据则服务器返回cathe-contorl给浏览器，浏览器缓存在本地，下次重复请求的时候就直接访问浏览器缓存读取数据

协商缓存：是浏览器客户端首次想服务器发出请求，服务器返回last-modifed，下次请求带上if-last-modified，若下次请求和上一次请求没有变化则服务器返回304表示资源不需要变更，不需要重新获取数据

#### 105.数组中数据随机发放

#### 106.promise，原型链等

原型链就是一个函数方法的实例的`__proto__`指向该函数方法的`prototype`，且该函数方法的`prototype`的`__proto__`指向该函数方法继承的父类函数的`prototype`,则可以得出，若通过实例调用该函数的方法，若未在函数内找的则向他继承的函数的原型上去查找，一层一层的查找的链路就是原型链

#### 107.react中如何卸载组件

useEffect中return的回调函数是清除方法会在组件销毁的时候执行，也就是下一次渲染前执行上一次的清除

#### 108.跨域如何处理

1. 使用Jsonp处理
2. 使用Coser处理请求头从服务端进行跨域处理

#### 109.浏览器的缓存如DNS解析

输入地址到浏览中的过程是什么：

1. 浏览器将请求地址通过DNS解析成IP地址（若其ip地址之前已经访问过则直接从缓存中获取）
2. 浏览器向服务器发送http请求，服务器解析接受请求，返回数据（TCP的三次握手：客户端发送请求，服务端接受请求成功，返回数据给客户端，客户端接收数据成功后返回成功给客户端）
3. 浏览器接收返回的数据，将css转换成CSSOM ，html转换成DOMTree，将CSSOM和DOMTree结合起来渲染到界面，若遇到script标签的js代码则停止渲染先加载js代码再进行渲染

#### 120.工作时候使用的工具

小乌龟、git 、compare对比工具，postman、版本发布，及文件打包

#### 121.居中对齐的方式

```css
//方法一弹性盒子、或者栅栏布局 父级
.container{
    display:flex/grad;
    flex-derection:row;
    justify-content:center;
    align-item:center;
}
//子级
.child{
    width:100px;
    height:100px;
}

//方法二 子绝父相 父级
.container{
    position:relative;
}
.children{
    position:absolute;
    top:0;
    right:0;
    left:0;
    bottom:0;
}
```

#### 122.react中父子组件通讯

react中数据是单向流动的，由父级流向子级，子级不能流向父级

父级数据传入子级，通过props进行传递

父级获取到子级的数据：可以通过子级的回调函数传入参数，调用父级的方法，由此父子可以获取到子级回调函数传入的参数数据

#### 123.react中受控组件和非受控组件

受控组件指的是：该组件内的数据state由自己控制，可变化

非受控组件:则是通过refs绑定组件，从外部获取组件的属性和状态，

#### 124.MVC和MVVM的区别

MVC:Model-view-contorl    ：用户操作view视图改变，则contorl业务控制发送改变请求到model服务端，服务端改变数据后将新数据返回view展示出来

MVVM：Model-view-view-Model   ：用户操作view视图交互，则viewModel进行数据变化，双向数据绑定变化返回渲染到view，其中model和viewModel进行ajax数据请求交换，返回JSON数据

其中react属于用户通过view进行数据交互，前端将view与view-model进行双向数据绑定，view改变则数据改变，数据改变则view变化，后端和前端通过ajax或者axious将viewmodel和model的后端数据进行传递

**MVVM执行方式：不直接修改DOM结构等，将DOM数据转换成JS中对象的形式也就是虚拟DOM进行修改，从而更新界面view展示渲染**

#### 125.数据库增删改查

```sql
create table userDB
//增加一条数据
insert into  userDB (userName,password,telephone,age)values(?,?,?,?)
//查找一条数据的userName是什么
select * from userDB where userName=?
//模糊查询
select * form userDB where username like?	
//删除一条 username为*age为*的数据
delete form useDB where userName=?and age=? limit 1
//更新数据
update userDB set userName=?,password=?,telephone=?,age=? where id=? 
```

#### 126.重排和重绘

重排：元素的位置及大小，或者视口的改变会触发重排

重绘：将元素位置大小得知后，将元素展示在界面上的实际像素是重绘

重排必然引起重绘，重绘不一定引发重排

避免频繁触发重排重绘

1. 减少DOM操作，将多次修改DOM的操作合并成一次处理
2. 将DOM先进行隐藏，期间进行重排重绘的改变元素位置大小等操作，操作完成后在显示出该DOM
3. 使用position：absolute 绝对定位脱流减少重排重绘
4. 使用CSS3样式：如transform 变换 opcity 透明度 filters过滤等

#### 127.盒模型有几种

一种W3C规范的标准盒模型：

盒子大小为：`content+padding*2+border*2+margin*2`其中width===content

一种为IE盒子模型：怪异盒模型

盒子大小为：`content+margin*2`其中width=== content+padding+border

设置标准盒模型:`box-sizing:content-box`

设置IE盒模型：`box-sizing:border-box`

#### 128.BFC

block format context 盒子区域标准规范，表示该区域遵守的标准规范，一种解决方法

用于解决：

1. 两个兄弟盒子上下排列，margin高度折叠（将两个盒子都包裹一个container设置overflow：auto、hidden）
2. 子级元素float则父级盒子高度坍塌（将父级盒子添加overflow：auto、hidden）
3. 兄弟盒子脱流，另个盒子并排被折叠 （将被折叠的盒子添加overflow：auto、hidden）

#### 实现文件下载

```javascript
.then((res)=>{
    //后端返回的数据处理成需要的字符串·
   	let excelStr= res.join(',')
    let data ='/ufeff'+excelStr
    const fileName = '用户默认密码.txt'
    //创建一个a标签
    const excelA = document.createElemnt('a')
    //new一个blob流文件
    let myBlob = new Blob([data],{type:'text/csv,charset=UTF-8'})
    //创建下载链接
    let URL = window.URL.createObjectURL(myBlob)
    let URL = webkitURL.createObjectURL(myBlob)
    excelA.herf = URL
    excel.download = fileName
    document.body.appendChild(excelA)
    excelA.click()
    data = null
    blob = null
    document.body.removeChild(excelA)
}
).catch((err)=>{
    console.log(err)
})
```

#### 实现文件预览

```javascript
//实现预览方式一
if (/(jpg|png|jpeg)$/gi.test(item.name)) {
      // 图片预览
      const res: any = await filePreview(item.fileKey)
      url = res.data.data
      if (url) {
        setPreviewFileInfo({
          fileType: '',
          filePath: url,
        })
        setImgVisible(true)
      }
    } else if (/pdf$/gi.test(item.name)) {
      // pdf 使用浏览器原生预览功能（react-file-viewer不能完美预览）
      setRequestLoading(true)
      const res: any = await filePreview(item.fileKey)
      url = res.data.data
      window.open(url)
      setRequestLoading(false)
    }
```



```javascript
/*******************************/
npm install react-excel-renderer --save
/*******************************/
//创建一个名为ExcelExport的组件，并利用react/jsx-concurrent-mode特性实现并发渲染
import React, { useState } from 'react';
import ReactDataSheet from 'react-datasheet';
import 'react-datasheet/lib/react-datasheet.css';
import { OutTable, ExcelRenderer } from 'react-excel-renderer';

const ExcelPreview = () => {
  const [dataLoaded, setDataLoaded] = useState(false);
  const [rows, setRows] = useState([]);
  const [cols, setCols] = useState([]);

  const fileHandler = (event) => {
    let fileObj = event.target.files[0];

    ExcelRenderer(fileObj, (err, resp) => {
      if (err) {
        console.log(err);
      } else {
        setDataLoaded(true);
        setCols(resp.cols);
        setRows(resp.rows);
      }
    });
  };

  return (
    <ConcurrentMode>
      <div>
        <input
          type="file"
          onChange={(event) => fileHandler(event)}
          style={{ padding: '10px' }}
        />
        {dataLoaded && (
          <ReactDataSheet
            data={rows}
            valueRenderer={(cell) => cell.value}
            sheetRenderer={(props) => <OutTable {...props} />}
          />
        )}
      </div>
    </ConcurrentMode>
  );
};

export default ExcelPreview;
```

#### 实现组件缩放

```javascript
/*
 * @Author: 韩静文/YC01834
 * @Date: 2023-03-23 13:43:40
 * @Description: 全屏
 */
import React, { HtmlHTMLAttributes, useEffect, useRef, useState } from 'react'
import styles from './index.module.less'
import iconScreenNormal from '@src/static/assets/icon_screen_normal.png'
import iconScreenFull from '@src/static/assets/icon_screen_full.png'
import _ from 'lodash'

interface FullScreenProps extends HtmlHTMLAttributes<any> {
 fullEleRef //当前需要被缩放的组件，需要被全屏的组件
  warpRef //目标页面最大的容器组件
  fullStyle? //需要被全屏组件的样式
}

const FullScreen: React.FC<FullScreenProps> = (props) => {
  const { fullEleRef, warpRef, fullStyle, ...rest } = props
  const divRef = useRef<any>()
  const [isFull, setIsFull] = useState<boolean>(false)
  useEffect(() => {
    onWindowResize()
    window.addEventListener('resize', onWindowResize)
    return () => window.removeEventListener('resize', onWindowResize)
  }, [])
  //监听窗口缩放,将组件的position设置为none恢复原始大小
  const onWindowResize = _.debounce(() => {
    fullEleRef.current.style = {
      width: '100%',
      height: '100%',
      position: 'none',
      top: 'none',
      left: 'none',
      backgroundColor: '#fff',
    }
    setIsFull(false)
  }, 500)
  /*
  *给缩放图标绑定点击事件，当缩放图标为展开icon时候，再进行点击则设置样式position：fixed，
  脱流，Index：100
  设置当前组件的width为页面最大的容器盒子组件的clientWidth和clientHeight
  为收起时，再次点击图片则设置position：none，Width和height 100%
  */
  const click = () => {
    if (!isFull && fullEleRef.current) {
      fullEleRef.current.style.width = `${warpRef.current.clientWidth}px`
      fullEleRef.current.style.height = `${warpRef.current.clientHeight - 32}px`
      fullEleRef.current.style.position = 'fixed'
      fullEleRef.current.style.top = fullStyle ? fullStyle.top : `${warpRef.current.offsetTop}px`
      fullEleRef.current.style.left = fullStyle ? fullStyle.left : `${warpRef.current.offsetLeft}px`
      fullEleRef.current.style.backgroundColor = '#fff'
      fullEleRef.current.style.padding = '0 16px'
    } else if (fullEleRef.current) {
      fullEleRef.current.style = {
        width: '100%',
        height: '100%',
        position: 'none',
        top: 'none',
        left: 'none',
        backgroundColor: '#fff',
      }
    }
    setIsFull(!isFull)
  }
  return (
    <button ref={divRef} className={styles['btnFullScreen']} onClick={click}>
      <img src={isFull ? iconScreenFull : iconScreenNormal} alt={isFull ? '展开' : '收缩'} />
    </button>
  )
}

export default FullScreen

```

#### 实现组件卡片分页，取消选中及选中的效果

```javascript
  /**
   * 查询上下滚动formCard表单卡片点击触发的界面
   */
  const searchCardOnClick = (record) => {
    //横行卡片组件显示
    setArrowShow(true)
    //获取选中的card下标
    const checkedIndex = cardFormData?.findIndex((item) => item.id === record.id)
    //设置当前被选中卡片下标
    setCheckedIndexCard(checkedIndex)
    setDynamicTableHeader(dynamicHeader)
    //当前选中的数据所在的页，若formCard表单选择的卡片下标不是四的整倍数，取商向上取整，若是倍数直接获取商
    let currentPageSize: any = 0
    if ((checkedIndex + 1) % 4 > 0) {
      currentPageSize = Math.ceil((checkedIndex + 1) / 4)
    } else {
      currentPageSize = (checkedIndex + 1) / 4
    }
    //所有卡片一共多少页
    const dataLength = cardFormData.length
    let pageSize: any = 0
    if (dataLength % 4 > 0) {
      pageSize = Math.ceil(dataLength / 4)
    } else {
      pageSize = dataLength / 4
    }
    //设置数据当前页、总页数
    setCurentCardPageSize(currentPageSize)
    setCardPageSize(pageSize)
    //调用接口查询选中的card对应的底下单选列表数据展示
    cardChangeTreeQuery({ ...record })
    setCheckedCardData(record)
  }
  
	/**
   * 被选中取消选中的卡片样式
   */
  const styleChange = (data) => {
    let styleObj = {}
    const checkedIndex = cardFormData?.findIndex((item) => item.id === data.id)
    if (arrowShow) {
      if (checkedIndex == checkedIndexCard) {
        styleObj = {
          backgroundColor: '#eaf5ff',
          borderColor: '#3f87ef',
        }
      }
    } else {
      styleObj = {}
    }
    return styleObj
  }
  /**************************HTML*************************************/
    {curentCardList.map((item, index) => (
            <Card
              key={item.id}
              className={styles['search-card-change']}
              style={
                curentCardList.length === 4
                  ? styleChange(item)
                  : Object.assign(styleChange(item), { marginLeft: '14px' })
              }
              onClick={() => searchCardOnRowClick(item)}
            >
              <div className={styles['search-card-content-change']}>
                <div className={styles['search-card-content-change-left']}>
                  <p>计划流水号</p>
                  <p>计划类型</p>
                  {!arrowShow && <p>企业名称</p>}
                </div>
                <div className={styles['search-card-content-change-right']}>
                  <p>{item?.planNumber}</p>
                  <p>{item?.planTypeName}</p>
                  {!arrowShow && <p>{item?.unitName}</p>}
                </div>
              </div>
            </Card>
        ))}
```

#### useMemo的使用案例

```javascript
/**
   * 横行左右翻页表单card时候的点击：获取当前被点击的卡片数据，设置为被选中状态
   */
  const searchCardOnRowClick = (record) => {
    //获取动态表头
    let dynamicHeader
    if (!isEmpty(checkedCardItemRef.current?.separateName)) {
      dynamicHeader = checkedCardItemRef.current?.separateName?.split(',')
    } else {
      dynamicHeader = []
    }
    setDynamicTableHeader(dynamicHeader)

  }
```

#### 技术难点

编写可编辑列表及辅助查询 ，该可编辑列表组件和辅助查询组件需要兼容两个不同的模块使用，我本人是做的资金预算模块，需要和支付结算模块对接该组件，该组件需要实现完全受控，首先保证业务功能交互正常，其次需要

在经办时兼容两个模块的不同业务场景进行交互变化，包括界面组件数据回显、必输金额的校验提示，及金额的预警，及普通经办界面和弹窗经办界面的自适应样式适配等

#### 项目背景及主要业务

财资管理云CBS8这个系统主要是帮助客户实现集团企业管理底下的成员单位的资金预算管理，账户管理，支付结算，信贷和融资、投资理财等业务，前端架构主要使用的微前端技术react+ts+hooks+redux,每个业务模块单独运行开发，上线运行时通过基座将全部的模块导入打包处理，我主要负责的是资金预算模块和支付结算模块的对接，资金预算涉及到自定义日历、预算项维护、预算模板维护、预算录入、预算调整、预算批复、预算勾兑、上划下拨维护、上划下拨账号设置等

#### react Native

#### 万元及元的单位数据转换，虚拟滚动的实现原理优化

预算查询界面可以查看每个成员单位下的预算项及预算计划，但是由于预算项事树状数据，则没有使用分页，当后端返回数据过多的时候，滑动书表格则会出现卡顿严重的问题，但是可以通过antd4 提供的virtualized table for antd 4插件抛出的useVThook实现，组件列表虚拟滚动，计算当前列表的高度，监听列表滚动条滚动时触发滚动事件，滚动距离多少时展示其中部分数据，剩余部分不进行渲染，直到滚动条到目标位置渲染剩余的列表数据

```javascript
/*
 * @Author: 韩静文/YC01834
 * @Date: 2024-04-26 16:29:30
 * @Description:
 */
import BigNumber from 'bignumber.js'

/**
 * @description:将金额进行单位转化
 * @param:amountInYuan 需要转化的金额
 * @param:action 转化方式：元转万，即除法（‘dividedBy’），万转元即乘法（‘multipliedBy’）
 * @param:amountUnit 转换单位，未传默认万元，比如万元即：10000
 */
export const convertAmountUnit = (amountInYuan, action: 'dividedBy' | 'multipliedBy', amountUnit?): number => {
  if (typeof amountInYuan !== 'number') {
    // 如果传进来转换的金额不是数值，进行转换为数值，如果转换后的值为NaN，则直接显示原值，不进行金额转换
    if (isNaN(Number(amountInYuan))) {
      return amountInYuan
    }
    amountInYuan = Number(amountInYuan)
  }
  // 使用BigNumber创建金额对象
  const bigAmount = new BigNumber(amountInYuan)
  // 转化为其他单位元，如果未传入单位，默认单位为万元
  let amountInWan
  if (action === 'dividedBy') {
    amountInWan = bigAmount.dividedBy(amountUnit || 10000)
  } else if (action === 'multipliedBy') {
    amountInWan = bigAmount.multipliedBy(amountUnit || 10000)
  }
  // 保留2位小数, 返回结果
  return Number(amountInWan.toFixed(2))
}


/*
 * @Author: 韩静文/YC01834
 * @Date: 2024-04-23 19:26:19
 * @Description:
 */
import React, { useEffect } from 'react'
import { useVT } from 'virtualizedtableforantd4'
import { VtOpts, TableComponents } from 'virtualizedtableforantd4/dist/cjs/vt'

interface UseVirtualProps extends VtOpts {
  virtual?: boolean
  scrollDom?: HTMLElement
  components?: TableComponents
}

const useVirtual = (props: UseVirtualProps, deps: React.DependencyList = []) => {
  const { virtual, scrollDom, components, ...vtOpts } = props
  const [vt, setComponents, tableRef] = useVT(() => ({ overscanRowCount: 10, ...vtOpts }), [...deps])
  useEffect(() => {
    if (components) {
      setComponents(components)
    }
  }, [components])
  useEffect(() => {
    if (scrollDom) {
      const io = new IntersectionObserver((entries) => {
        // 菜单切换时由于滚动条会被重置，但是页面并未卸载状态未被重置导致页面可能会留白，所以需要手动将滚动条重置为0
        if (!entries[0].isIntersecting && virtual) {
          tableRef.current.scrollTo(0)
        }
      })
      io.observe(scrollDom)
      return () => {
        io.disconnect()
      }
    }
  }, [scrollDom, virtual])
  return virtual ? vt : components
}

export default useVirtual


const VC = useVirtual(
    {
      virtual: propsVirtual,
      scrollDom: tableRef.current?.querySelector('.ant-table-body'),
      scroll: { y: scroll?.y },
      components: components as any,
    },
    [scroll?.y]
  )

```

```html
 		<Table
          className="divide-table"
          ref={tableRef_}
          rowKey={rowKey}
          components={{
            ...VC,
            header: {
              cell: ResizableHerder,
              wrapper: (props) => {
                const { children, ...restProps } = props
                return <thead {...restProps}>{children}</thead>
              },
            },
          }}
          {...restProps}
       	 />
```

#### 可编辑表格的实现

修改Table组件component属性中的Cell和roll，每一格组件和每一行的组件，在列表的每一格进行值的输入与存储，在列表的每一行外部进行form表单的绑定，将界面上输入的数据存储在form表单里，解决了表格校验的问题，在提交时将列表每一行的form表单数据遍历进行校验，并遍历获取列表全部的数据

#### 重复调用接口，使用axios实现取消调用的方法，永远只取最后一次调用的结果

当用户频繁修改数据，该币种数据，需要调用后端接口获取实时汇率，则会导致频繁触发接口，每个接口查询返回数据的时间不同，产生异步问题，导致金额根据汇率计算回显不准确，则使用axios.cancelToken方法的，在调用接口钱取消前面多次的调用，永远获取最后一条调用接口返回的汇率值

#### 平时在哪学习

在掘金和慕课网上学习，主要是学习各种官方文档并自己练习，平时关注阮一峰老师的博客比较多

#### 自我介绍

我的名字叫韩静文，2021年毕业于武昌工学院的计算科学与技术专业，毕业后在招银云创工作了三年，主要使用的技术栈为react 和angular，熟练掌握javascript和html和css技术，工作中主要参与到TMS招商局财资管理系统及CBS8财资云系统的前端开发中，主要负责资金预算模块开发，我所在的项目组是资金预算项目组，我负责资金预算的页面开发和支付结算模块的组件对接

#### React Diff

react diff是react基于虚拟DOM发生变化时进行新旧虚拟DOM对比的算法，改善原本递归算法的空间复杂度，优化算法基于三个层级规律，首先进行Tree节点同级别对比，若发现同一层级节点发生改变，直接将原节点删除，创建新的节点，其次进行component组件之间对比，组件的变化，若删除父组件底下的同级子组件，则直接删除整个子组件包括该子组件的子组件，再创建子组件，最后进行element元素节点之间的对比，若只是移动的element则不会删除原节点，会根据Key移动变换对应节点

#### React Fiber

react fiber 架构，是react团队用于解决浏览器的js引擎和页面渲染引擎不能同步执行，导致若js代码过于复杂等渲染会出现卡顿的问题优化出的一种算法，fiber架构添加了任务优先级先后执行机制，添加了requestIdcallBack异步回调机制，一个react VDOM对应两个fiber对象链表，fiber对象存储了VDOM的属性，包括tag名执行顺序，包括此次变更修改的状态、将要执行的任务等，fiber把渲染过程拆分成多个子任务，一次只执行一部分，剩下的交给浏览器引擎判断，防止页面卡顿

#### 微前端

sigle-spa qiankun

#### 数组的方法及字符串的方法

**数组**：纯函数：slice 

不改变原数组 concat filter map some every reduce join

splice第一个参数截取下标，第二个参数是截取数组长度，后面为截取后替换的参数

slice第一个参数为截取的下标，第二个参数为截取截止的下标

**字符串**

split 通过什么分割成数组

subString 不返回最后一个元素

substr 返回最后一个元素，第二个参数为截取长度

slice 不返回最后一个元素

repalce等

#### 箭头函数和普通函数的区别

* 箭头函数的this永远指向它外部的层级
* 普通函数可以new 实例

#### 瀑布流!!!

#### 括号算法

#### cavans

#### less的变量定义与继承及计算

* less中通过@定义变量，sass通过$定义变量

* less变量的作用域会随着选择器嵌套发生改变，sass变量作用域不会发生改变

* sass可以使用 if else for，less不行

  ```css
  .a{
      
  }
  &:extend(.a){
      
  }
  ```

#### sass的基本使用用法

* 变量 $ a
* 嵌套 $a定义的变量存在作用域
* 混合 @mixed @include @content占位符
* 继承 @extends
* @for $a  @each @function $a*$b + - /

#### TypeScript的类型限定、装饰器、还有一些插件

number string boolean undefined null object array any enum tuple void 

#### TypeScript中的type 和interface的区别

* type可以定义基本类型和对象类型，interface只能定义对象类型
* interface可以通过extends继承，type是通过&合并类型

#### webpack打包的模式

* development
* production
* none

#### 优化webpeck打包的方法

* js代码压缩  tersetPlugin 丑化代码
* html文件代码压缩 htmlWebpckplugin
* css代码压缩 压缩空格 css-minizer-webpck-plugin
* 文件大小压缩 减少http传输过程中的损耗
* 图片静态文件压缩
* 代码分离 打包成多个小的包，按照优先级编译
* 内联chunk

#### 优化webpack构建速度

* 优化loader配置
* 合理使用reslove.modules
* terser启用多线程

#### 如何实现像素展示10px，最小为12px

通过使用transform变化sacale大小

#### 算法和数据结构有哪些

数据结构：

* 数组：同一类型的数据组成的有序集合
* 栈：只允许一段插入、删除，先进后出，数据压入栈底，读取数据从顶部弹出
* 队列：和栈一致，线性结构，允许前端删除，后端插入数据，先进先出
* 链表：由节点组成，节点包括一个元素的数据域，一个指针地址
* 树：只有一个顶端根节点，可以有两个以上的子节点
* 堆：树形数据结构，每个节点都有一个值，根节点的值最小或者最大
* 图
* 散列表

#### 如何实现树形数据的递归

```javascript
const treeToFlat = (treeObj,newObj)=>{
    treeObj.map((item,index)=>{ if(Array.isArray(item.children)&&item.children.length>0){
            treeToFlat(item.children,newObj)
        }else{
           newObj.push(item) 
        }                   
    })
    return treeToFlat
}
```

#### 组件设计模式!!!

#### 公共组件的设计模式!!!

工厂模式

单例模式

#### react中自定义hooks的实现!!!

1. 自定义hook命名必须是use开头命名，必须是函数方法
2. 函数内编写可复用逻辑
3. 返回参数是一个数组，包含了方法和更新状态

#### react中使用自定义hooks实现获取字典接口的

1. 编写一个自定义函数方法，使用use开头命名
2. 定义一个调用接口的方法load，load为字典调用时的方法
3. 设置一个loading的state状态，当字典接口调用时设置loading为true，反之false
4. 定义一个data的state状态，将接口返回数据存储
5. 定一个error状态，若接口报错就返回error状态
6. 函数return data,loading,error，load三个状态

#### 一个盒子从左边移动到右边

#### animation动画的实现

animation-name

animation-duration 5s

animation-timing-function linear

animation-delay:10s

animation-derection:reverse

#### 虚拟列表的实现原理

```javascript
updateVisibleData(scrollTop) {
  scrollTop = scrollTop || 0;
  const visibleCount = Math.ceil(this.$el.clientHeight / this.itemHeight); // 取得可见区域的可见列表项数量
  const start = Math.floor(scrollTop / this.itemHeight); // 取得可见区域的起始数据索引
  const end = start + visibleCount; // 取得可见区域的结束数据索引
  this.visibleData = this.data.slice(start, end); // 计算出可见区域对应的数据，让 Vue.js 更新
  this.$refs.content.style.webkitTransform = `translate3d(0, ${ start * this.itemHeight }px, 0)`; // 把可见区域的 top 设置为起始元素在整个列表中的位置（使用 transform 是为了更好的性能）
}

handleScroll() {
  const scrollTop = this.$el.scrollTop;
 	this.updateVisibleData(scrollTop);
}
```

#### 二分查找法

```javascript
const halfSearch =(arr,target)=>{
    let left = 0
    let right = arr.length-1
     while(left < right){
         let mixed = parseInt(Math.floor(left+right)/2)
           if(target<arr[mixed]){
              	 right = mixed-1
              }else if(target>arr[mixed]){
                 left = mixed+1
              }else{
                 return arr[mixed]
              }
  
           }
    return -1
}
```

#### 二分查找发查找峰值

```javascript
const halfSearch = (arr)=>{
    let left = 0
    let right = arr.length-1
    while(left<right){
          let middle = parseInt((right+left)/2)
          if(arr[middle-1]<arr[middle]&&arr[middle]>arr[middle+1]){
              return middle
             }
        	if(arr[middle-1]>arr[middle]){
                right = middle
             }else{
               left= middle+1
             }
          }

    }
```

#### 通过获取当前定位

```javascript
const GEO = new BMap.Geolocation()
GEO.getcurrentPosition((r)=>{
    if(GEO.getStatus === 'success'){
        getAddress(r.point.lng,r.point.lat)
       }
})

const getAddress = (n,a)=>{
    const getAdd = new BMap.GeoCoder()
    getAdd.getLocation(new BMap.Point(n,a),(result)=>{
        result.province
        result.city
        result.address
    })
    
}

```

#### 前端路由跳转带入数据使用什么

`history.go()`

historyRoute 通过服务器访问路由地址

hashRoute 没有服务器时使用路由跳转，地址有#

#### 上传多个图片或者文件前端发送数据的格式是什么

#### setState的异步问题如何处理

```javascript
setState({count:this.count++},()=>{
//这里获取的值是最新的State
})
```

#### 获取所有父节点和子节点

```javascript
const myD = document.getElemntById('#myName')
console.log(myD.parentNode)
console.log(myD.childNode)
```

#### abc入栈，出栈顺序

```javascript
1.a入栈，出栈。b入栈，出栈。c入栈，出栈。结果是abc
2.a入栈，b入栈，出栈,a出栈,c入栈，出栈。结果是bac
3.a入栈，b入栈,出栈,c入栈，出栈,a出栈。结果是bca
4.a入栈，出栈,b入栈,c入栈，出栈,b出栈。结果是acb
5.a入栈，b入栈，c入栈，c出栈,b出栈,a出栈,。结果是cba
```

#### 翻转二叉树

#### 为什么react中需要使用key

#### ES6 ES7 ES8新特性

ES7：

1. array.prototype.includes   [3,4,5,6,10].includes(0) //false
2. ** 指数幂  let a =10 a**2 === 100

ES8

async await 异步函数函数关键字，await表示需要await需要异步等到返回的函数接口数据

Object.keys values entries [['b',4],['a',1]]

Object.getOwnPropertyName()

参数可以使用等

#### axios和ajax和Promise

![1726591655340](C:\Users\xiaoha\AppData\Roaming\Typora\typora-user-images\1726591655340.png)

axios是基于Promise的http请求客户端，通过xhrhttprequest进行封装的请求方法，可以使用.then语法,支持请求拦截，响应拦截，且支持拦截器配置等，get post put delete请求方法进行接口调用封装，支持封装接口返回处理等

* 浏览器和node.js可以发送http请求
* 支持拦截请求
* 支持取消请求
* 支持处理请求返回结果
* 支持配置跨域
* 支持Promise相关语法
* 自动将结果转换成json

ajax也是通过xhrHttpRequest进行封装的异步或者同步请求方法，不可以使用.then，回调函数处理异步函数调用会导致错误重复处理等异步回调地狱问题

Promise是es6提出的一种处理异步返回结果的机制与方法

#### 构建项目和组件的流程，都涉及到哪些文件及配置

create react myReactApp

crc

-api

-static

-common

-component

-pages

-route

-hooks

-store

index.ts

-webpack-json

-package,json

-eslint.json

-perrter.ignor

-coderview

####  Generators 

- Generators:生成器让你“暂停”单个函数，而不会暂停整个程序的状态，但代码要稍微复杂一些，以使代码看起来像自上而下地执行

#### 创建公共组件的步骤及过程

#### 设计模式

#### spl，连表查询、删除整个表格，分组查询

select * form table1 inner join table1 on 条件

select * form table group by name，color，type

#### keep-alive

组件不需要销毁，或者重新更新时候使用，不会触发生命周期，在某些场景下不需要页面重新渲染

使用onActived监听组件被激活时候执行方法

使用onDeactived监听组件被销毁，页面退出时候触发的方法

#### 不通过代码进行bug调试，在控制台定位性能问题，调试并发情况下界面性能

代码调试：

* debbger
* 控制台source界面打断点
* console.log
* 控制台查看报错

性能问题：

* console.time('id') console.timeEnd('id')计算一段代码执行的时间
* 控制台的performance（查看js代码执行堆栈信息、占用内存情况及执行时间，还有数据接口请求性能）
  * disable javascript samples 用于采集js执行的堆栈信息，js代码性能及时间，内存占用情况
  * enable advance paint instrumentation 启用高级绘制仪器，用于记录详细的绘制信息，包括绘制操作时间，持续时间，绘制区域，选中其中一帧，查看layers，用于查看渲染操作的时间和持续时间，判断渲染操作占用了较长时间，可定位导致页面渲染缓慢的操作
  * CPU和Network ，cpu选项可以用于降低cpu性能用于调试，network可以调整不同的网络情况，网络不佳或者cpu性能不佳的界面运行情况
  * hardWare concurrency，用于模拟性能并发性能，可以选择从1到最大硬件并发性能水平之间的值，以模拟不同硬件环境，可以观察不同硬件并发性能水平下的性能表现，优化页面并发处理和多线程任务
  * 报告区
    * 概览区：x方向是时间长度 y方向是cpu占用情况、NET网络请求情况，HEAP堆内存使用量，ScreenShots绘制每一帧的快照
    * 性能报告区：summary选项卡展示了当前任务的具体信息，包括长任务警告，总热内时长，及各个子任务的耗时。bottom-up选项卡将当前任务下所有的活动都展示出来，并且更具时间进行倒序排序，可以清晰看出哪个任务耗费较长时间

#### pendding是前端请求中，还是后端接口查询中

一般来说是后端处理请求时间超长，可能是后端接口代码陷入死循环，或者前端请求头配置错误，一般来说前端请求头或者入参，地址错误会报错，所以后端导致接口一直pendding的原因较多

#### 前端如何模拟并发请求的性能优化

通过使用浏览器控制台的performance中的 hardWare concurrency，模拟并发场景的页面性能展示问题

#### 使用过哪些性能优化的操作及案例

#### token权限放在哪里，由前端还是后端限制权限

token由后端生成：用户登录后，前端将用户名和密码发送给后端，后端生成对应的token返回给前端

前端获取token：登录接口成功后前端将后端返回的token存储在cookies或者localStorege里面，在前端每次调用接口请求时，token放在请求头里发送给后端，后端对此解析用户是否有该权限

#### axios拦截器原理是什么

#### vite打包原理

#### v8引擎

#### node koa创建一个hello world

node内置模块

* path 路径地址

  * `__dirname`  当前js文件运行的目录的路径 src

    ```javascript
    const path = require('path')
    //拼接当前目录底下文件的地址
    let pa1 = path.join(__dirname,'/index')
    console.log(pa1)
    ```

  * `__filename`表示当前js文件运行的文件路径 filename（表示当前文件）

    ```javascript
    let extname = path.extname(__filename) //获取文件的后缀名
    ```

    

* fs 文件操作模块

* OS 获取当前操作信息的信息



创建node项目步骤：

* npm init 初始话一个项目的package.json

  

#### TypeScript类型推导 string和number推导出是哪个类型

typeof 判断类型

as限定推断类型

#### interface和type的区别

* interface用于定义一个函数或者对象的入参类型，只能定义对象里的属性类型type可以定义基本类型、元组、对象等类型

* interface可以通过extends或者继承其他interface的数据类型，type通过交叉类型&联合类型或者|定义

* type可以使用 in关键字生成映射类型
* 默认导出export default时，interface可以通过同时声明并导出，type只能先声明后导出

#### 如何将项目发布到线上，发布流程是什么

![1727115335057](C:\Users\xiaoha\AppData\Roaming\Typora\typora-user-images\1727115335057.png)

#### 流水线是如何实现发布的

#### 数据库视图是什么

#### 如何实现图片的懒加载，不通过框架,js原生

图片一开始不是会全部展示，当滚动条滚动到对应图片才加载

img.offSetTop < clientHeight + scrollTop就加载对应图片

图片距离顶部的高度小于窗口视口的高度+已经滚动的高度就加载对应图片

```javascript
<img id='myImg' src='./prevent.png' data-realsrc ="./realPng1"/>
<img id='myImg' src='' data-realsrc ="./realPng2"/>
<img id='myImg' src='' data-realsrc ="./realPng3"/>
<img id='myImg' src='' data-realsrc ="./realPng4"/>
<img id='myImg' src='' data-realsrc ="./realPng5"/>
    <script type="text/javascript">
        const Images = document.querySelectAll('img')
        const lazyLoadImage = ()=>{
           const clientHight = document.documentElement.cilentHeight()
           const scrollTop = document.documentElement.scrollTop()
           for(x in Images){
               //图片的data-realsrc有值且图片距离顶部的高度小于窗口视口的高度+已经滚动的高度就加载对应图片
               if(Images[x].offSetTop < clientHight+scrollTop&& Images[x].getAttribute('data-realsrc){
                   Images[x].src = Images[x].getAttribute('data-realsrc')
                   //不让显示过的图片再次显示
                   Image[x].removeAttribute('data-realsrc')
                  }
           }
        }
        //页面加载的时候
        window.onload = lazyLoadImage
		//窗口滚动的时候
        window.onScroll= lazyLoadImage
        
    </script>

//jquery
img1.lazyLoad({
    event:'sroll',
    container:window,
    ...
})
```

```JavaScript
//react 懒加载
lazy.load
```

#### 图片预加载

通过提前加载图片到本地，遍历图片src地址，new Image 实例，将每个src地址赋值给Image实例的src，实现预加载，下次使用图片时可以直接从缓存获取图片，通过onload监听预加载完成

```javascript
//通过提前加载图片到本地，遍历图片src地址，new Image 实例，将每个src地址赋值给Image实例的src，实现预加载，下次使用图片时可以直接从缓存获取图片，通过onload监听预加载完成
const imageSrcList = [
    './preImage1.png',
    './preImage2.png',
    './preImage3.png',
    './preImage4.png',
    './preImage5.png',
    './preImage6.png',
    './preImage7.png',
    './preImage8.png',
]
//遍历每个image的src ,new Image实例
for(x in iamgeSrcList){
    let imageObj = new Image()
    imageObj.src = iamgeSrcList[x]
    imageObj.onload = ()=>{
        console.log('图片预加载完毕',iamgeSrcList[x])
    }
    //另一种监听写法	
    //imageObj.addEventlisten('load',()=>{
       // console.log('图片预加载完毕',iamgeSrcList[x])
    //})
}
```

#### 接口数据预加载如何实现？接口需要三秒但是需要在一秒内展示出数据



#### 闭包是什么，原理

函数作为参数传入另一个函数，或者函数作为另一个函数返回，

内部函数访问外部函数的变量，改变量不会被外部访问或者修改

防止变量污染，但可能导致变量不能释放

闭包内变量不能被清除原因：函数作为返回值被返回，是全局作用域，window在标记清除时可以触及则不会被清除，而该函数引用了外部函数的变量也不会被清除

#### 内存回收机制

js周期性的进行变量及函数的清除销毁，使用标记清除法

标记清除法：js从window开始查找不可触及的变量及方法，将其清除内存

#### 事件循环机制是什么，原理，10个微任务和10个宏任务怎么执行

代码按照从上到下执行，分为同步和异步任务，先执行同步任务，执行到Promise的异步任务的微任务则放在微任务队列中，执行到settimeout宏任务时则放入宏任务队列中，继续执行剩余的同步任务，所有同步任务执行完毕以后，事件轮询机制会向微任务队列中查找需要执行的任务放入执行栈，微任务全部执行完毕后，在宏任务中找到需要需要执行的setTimeOut放入执行栈中执行，这一整套的事件轮询执行机制

#### setTimeout为什么设置时间为0还是最后执行，

 只有当调用栈清空后，事件循环才会从任务队列中取出回调函数并执行。这意味着，setTimeout指定的时间仅代表何时将回调添加到任务队列，而非准确的执行时间，因为调用栈可能在处理其他任务。因此，setTimeout的异步性质确保了它能够在不阻塞代码执行的情况下，按照设定的延迟时间执行回调函数‌ 

#### react中的hook分别替代了哪些生命周期

1. useState替代了construtor
2. useState里面的setState 替代了getDriverStateFormProps
3. useMemo替代了shouldComponentUpdate
4. useEffect(()=>{},[])替代了componentDidMount 
5. useEffect(()=>{},[state]) 替代了consponentDidUpdate
6. useEfect(()=>{return ()=>{}},[]) ,其中return的函数替代了componentWillUmount

![1727358736150](C:\Users\xiaoha\AppData\Roaming\Typora\typora-user-images\1727358736150.png)

#### useLayouEffect和useEffect的区别

useLayoutEffect用于DOM元素改变后，页面渲染前进行调用，相当于实现了一个防抖的效果

useEffect用于界面渲染后调用

#### react中的redux使用action在reducer纯函数内如何进行接口的调用

#### redux的使用

#### 合成事件，关于react事件是否都绑定在document上，有什么优缺点

合成事件SyntheticEvent是react模仿原生事件处理的一个事件对象

react的具体元素节点击事件，不是一个个绑定在具体的节点上，而是通过绑定在body和document顶级的元素上，通过时间冒泡监听到具体事件的触发实现的

优点：事件发生后，由外部元素统一监听器处理，在映射里找到真正的事件处理函数并调用，简化了事件处理和回收机制，提高了效率，减少内存开销。

* react所有事件都挂载在document对象上
* 当真实DOM元素触发事件，会冒泡到document对象上，再处理react事件
* 所以会先执行原生事件再处理React事件
* 最后再执行真实的document上挂载的事件

 ![img](https://static.vue-js.com/08e22ff0-d870-11eb-ab90-d9ae814b240d.png) 

#### react的document监听是如何判断是哪个节点元素触发的

阻止合成事件之间的冒泡，通过使用e.stopPropagation()

阻止合成事件和document上的事件间的冒泡，使用 event.nativeEvent.stopImmediateRopperation()

合成事件，获取具体是哪个元素触发的event.target

#### react点击事件的原理，是通过什么绑定在元素上的

点击事件没有绑定在真实的DOM元素上，而是把所有的时间绑定到结构的最外层，使用一个统一的事件进行监听

这个事件监听器上维持了一个映射来保存所有组件内部的事件监听和处理函数。当组件挂载或者卸载的时候，只是在在这个统一的事件监听映射上增加或者删除一些对象

#### react中父组件数据发生变化，子组件也会重新渲染吗？为什么？怎么解决

父组件props改变子组件也会重新渲染，可以使用Memo包裹子组件，只有当子组件的props传入改变才会重新渲染子组件

#### useContent用来做什么的，有什么优缺点

#### react中的key是用来做什么的

key的作用是用于判断元素是新创建的还是旧节点，若是旧节点则复用，新节点则创建或者移动，减少不必要的元素渲染

react中的key主要用于通过diff算法对比新旧虚拟DOM节点的key，旧的DOM节点复用，新的DOM节点添加，减少新增和删除DOM的操作和渲染时间提高性能，没有key的话会导致修改一个节点则所有的节点都需要重新生成并重新渲染

#### react中的ref

#### 如何获取某个组件的方法，使用useImperativeHandle抛出

#### 纯函数是什么？

特点：

1. 输入固定的值，结果可预测，按照原理返回
2. 不会修改原本输入的值
3. 不会产生副作用，不会修改原本传入的值或者外部的变量

例如：

* array方法中的slice方法，会截取固定长度的数组，返回一个新的数组，不会改变原数组，也不会改变外部变量和方法的值
* redux里面的reducer函数就是纯函数，deduce用于处理dispatch传入的action对应行为进行一些逻辑编写，不会改变传入的值，返回一个新的数据，也不会有别的副作用改变外部的方法和变量 （useReducer）

#### 函数柯里化

特点：

* 将一个函数需要的多个参数，分别使用多个函数传入处理
* 一个函数返回多个函数，每个函数处理单独对应的参数逻辑，拆分复杂逻辑，使每个函数的职责单一化

```javascript
const countNum = (x,y,z)=>{
    x=x*2
    y=y+6
    z=z/2
    return x+y+z
}
//柯里化
const kcountNum = (x) =>{
    x=x*2
    return (y)=>{
        y=y+6
        return (z)=>{
            z= z/2
            return x+y+z
        }
    }
}
```

#### useReducer的使用和特点

#### 自定义hooks需要注意特点？

* 函数必须使用use开头
* 必须是函数方法
* hooks必须在函数组件内调用
* hooks不可以在循环和条件语句中定义调用，会导致状态重复执行，状态显示不正确
* useEffect中使用`useEffect(()=>{setCount(count+1)})`界面展示coun会导致界面死循环
* 自定义hooks中可以使用useEffect

#### 手写自定义hooks

#### reduce常用

常用于计算累加

```javascript
let arr =[{name:'hanjingwen',age:12},{name:'yangjing',age:16}]
arr.reduce((prev,item)=>{
    prev[item.name] = item.age
   return prev
},{})
```

#### 手写一个监听窗口改变的自定义hooks

```react
const useResetWindow = ()=>{
    
    const [winConfig,setWinConfig ] = useState({
        width:window.innerWidth,
        height:window.innerHeigth,
    })
    
    //防抖函数，防抖：在频繁触发时，在设置的延迟时间后，只执行最后一次
    const debonce = (fn,delay)=>{
        let timer = null
        return (...args)=>{
            if(timer){
                clearTimeout(timer)
            }
            timer = setTimeout(()=>{
                fn.apply(this,args)
            },delay)
        }
    }
    
    useEffect(()=>{
        
        const handleWinRsize = ()=>{
             setWinConfig({width:window.innerWidth,height:window.innerHeigth})
        }
        
        //防抖处理窗口变化
        window.addEventListener('resize',debonce(handleWinRsize,100))
        
        return ()=>{
            window.removeEventListener('resize',()=>{
            setWinConfig({width:window.innerWidth,height:window.innerHeigth})
        	})
        }
    },[])
    
    return {
        winConfig,
        setWinConfig
    }
}
```

#### 虚拟DOM是什么

#### diff对比，生成新的DOM树是什么规范，如果全部新增那么不会有任何变化

diff就是找出新旧DOM树的可复用节点，剩下的界面新增的新增，删除的删除

#### fiber是用于解决什么，是什么原理，什么类型的任务先执行，什么任务后执行

解决js代码执行和界面渲染不能同步，js代码复杂组件复杂会导致页面卡顿问题

* 可中断渲染，将渲染任务拆分成小的任务，小任务等到js引擎空余的时候执行，渲染会暂停，渲染时候若遇到优先级高的任务会优先执行用户输入input框或者动画，暂停渲染，出完后再进行后续渲染
* 每个任务有优先级，fiber会根据每个任务的优先级，执行对应的渲染过程，如用户可感知的部分，输入或者动画先执行，数据返回更新界面后执行渲染

#### mysql和mongoDB各自使用的场景是什么？什么情况下选择mysql什么情况选择mongoDB

mysql用于频繁使用删除增加更新操作的场景，使用的表结构存储

mongoDB用于网页论坛评论，数据存储方式是类似于一个obj对象，文档存储

#### angular的生命周期

#### angular的组件传值

#### angular的双向数据绑定如何实现的

#### angular和vue和react有什么区别，你倾向于使用哪个框架

#### angular是否使用jsx或者template模板

#### webpack中的proxy原理及使用

#### 遍历二叉树

#### 嵌套的数组用深度遍历和广度遍历写出来

#### 递归

#### 迭代

#### 贪心算法

#### Promise原生

#### 项目业务梳理

#### 路由跳转

#### 自定义hooks实现防抖

```javascript
const useDebounce = (fn,delay)=>{
  return  useCallback((fn,delay)=>{
        let timer = null
        return (...args)=>{
            if(timer){
                clearTimeout(timer)
            }
            timer = setTimeout(()=>{
                fn.call(this,..args)
                timer = null
            },delay)
        }
    },[])
}
```

#### 移动端首屏加载过慢问题

1. 图像优化，图片懒加载，对图片进行压缩减小文件大小
2. 减少http请求，合并和压缩css和js文件，使用预加载技术
3. 压缩资源，压缩html、css，js文件大小，加快传输速度
4. 优化服务器响应时间，
5. 缓存策略，使用浏览器缓存，服务器缓存和CDN缓存，减少重复请求的依赖
6. 异步加载

#### 出现白屏问题如何解决

预加载

![image-20241010221927555](C:\Users\xiaoha\AppData\Roaming\Typora\typora-user-images\image-20241010221927555.png)

#### 屏幕的快照

使用cavans

#### redux的具体使用

#### 自定义hooks实现防抖

浏览器通historyRoute 使用pushState将路由地址改变显示对应界面刷新

#### 作用域链

块级作用域

#### 100个接口并发执行

#### 虚拟列表的组件如何处理滑动速度过快，界面出现空白的问题

1. 使用占位符，列表初始渲染时使用占位符，等数据加载完成后在替换成列表项
2. 预加载数据，预加载可视区域外的列表项数据，避免没有加载完成而出现白屏
3. 算法检查，仔细检查虚拟滚动的算法实现，确保没有计算错误，特别是关于可视区域大小列表项高度的计算

#### 虚拟列表的实现原理

```javascript
updateVisibleData(scrollTop) {
  scrollTop = scrollTop || 0;
  const visibleCount = Math.ceil(this.$el.clientHeight / this.itemHeight); // 取得可见区域的可见列表项数量
  const start = Math.floor(scrollTop / this.itemHeight); // 取得可见区域的起始数据索引
  const end = start + visibleCount; // 取得可见区域的结束数据索引
  this.visibleData = this.data.slice(start, end); // 计算出可见区域对应的数据，让 Vue.js 更新
  this.$refs.content.style.webkitTransform = `translate3d(0, ${ start * this.itemHeight }px, 0)`; // 把可见区域的 top 设置为起始元素在整个列表中的位置（使用 transform 是为了更好的性能）
}

handleScroll() {
  const scrollTop = this.$el.scrollTop;
 	this.updateVisibleData(scrollTop);
}
```

#### Jquery

##### 什么是Restful API

* 一种新的API设计方法（早已推广使用）

* 传统API设计：把每个URL当成一个功能

* **RestfulAPI设计，把每个URL当做一个唯一的资源，或者唯一的ID**

  * 尽量不用url参数

    ```javascript
    //传统
    /api/list?pageIndex=2
    //Restful
    /api/list/2
    ```

  * 用method表示操作类型

    ```javascript
    //传统
    post请求 /api/create-blog
    get请求 /api/get-blog?id=100
    //Restful
    post请求 /api/blog
    patch请求 /api/blog/100
    get请求 /api/blog/100
    ```

#### 图片懒加载

```javascript
<img id='Img1' src='preview,png' data-realsrc ="abc.png"/>
<script type= "text/javascript" >
    const img1 = document.getElementById('Img1')
//添加监听，当图片滚动到距离屏幕顶部距离多少时候才将剩下的图片返回
img1.addEventListen('scroll',()=>{
//
    console.log(img1.offsetX,img1.offsetY)
    img1.src = img1.getAttribute('data-realsrc')
})s
    </script>
```

#### 图片预加载

```javascript
//通过提前加载图片到本地，遍历图片src地址，new Image 实例，将每个src地址赋值给Image实例的src，实现预加载，下次使用图片时可以直接从缓存获取图片，通过onload监听预加载完成
const imageSrcList = [
    './preImage1.png',
    './preImage2.png',
    './preImage3.png',
    './preImage4.png',
    './preImage5.png',
    './preImage6.png',
    './preImage7.png',
    './preImage8.png',
]
//遍历每个image的src ,new Image实例
for(x in iamgeSrcList){
    let imageObj = new Image()
    imageObj.src = iamgeSrcList[x]
    imageObj.onload = ()=>{
        console.log('图片预加载完毕',iamgeSrcList[x])
    }
    //另一种监听写法	
    //imageObj.addEventlisten('load',()=>{
       // console.log('图片预加载完毕',iamgeSrcList[x])
    //})
}
```

#### 强缓存、协商缓存等

强制缓存：指浏览器首先向服务器发出请求，若这是首次请求数据则服务器返回cathe-contorl给浏览器，浏览器缓存在本地，下次重复请求的时候就直接访问浏览器缓存读取数据

协商缓存：是浏览器客户端首次想服务器发出请求，服务器返回last-modifed，下次请求带上if-last-modified，若下次请求和上一次请求没有变化则服务器返回304表示资源不需要变更，不需要重新获取数据

#### node

##### koa创建一个hello world

```javascript
const fs = require('fs');
 
// 同步读取文件内容
const content = fs.readFileSync('filename.txt', 'utf-8');
console.log(content);
 
// 同步写入文件
fs.writeFileSync('filename.txt', 'Hello, world!', 'utf-8');
```

node内置模块

* path 路径地址

  * `__dirname`  当前js文件运行的目录的路径 src

    ```javascript
    const path = require('path')
    //拼接当前目录底下文件的地址
    let pa1 = path.join(__dirname,'/index')
    console.log(pa1)
    ```

  * `__filename`表示当前js文件运行的文件路径 filename（表示当前文件）

    ```javascript
    let extname = path.extname(__filename) //获取文件的后缀名
    ```

    

* fs 文件操作模块

* OS 获取当前操作信息的信息

创建node项目步骤：

* npm init 初始话一个项目的package.json

#### typescript中omit、pick、partial、required等用法

omit：表示排除其中一项

pick：选取其中一项

partial：属性类型全部可选

required：属性类型全部必输

#### 业务整理

财资管理云CBS8这个系统主要是帮助客户实现集团企业管理底下的成员单位的资金预算管理，账户管理，支付结算，信贷和融资、投资理财等业务，前端架构主要使用的微前端技术react+ts+hooks+redux,每个业务模块单独运行开发，上线运行时通过基座将全部的模块导入打包处理，我主要负责的是资金预算模块和支付结算模块的对接，资金预算涉及到自定义日历、预算项维护、预算模板维护、预算录入、预算调整、预算批复、预算勾兑、上划下拨维护、上划下拨账号设置等

##### navigator

```javascript
const ua = navigator.userAgent //当前浏览器的信息
const isChrome  = ua.indexof('chrome') //ua就是浏览器信息简称
```

##### scrren

```javascript
screen.width
screen.height
```

##### loaction

```javascript
//地址信息
location.href //整个网址地址信息
location.protocal //http https
loaction.pathname //'/learn/199' 路径
loaction.search //?后面的内容
location.hash //#后面的内容
loaction.host //域名
```

##### history

```javascript
//路由前进后退信息
history.back() //后退
history.forword() //前进
```

#### 移动端前端面试

rem

弹性盒子

vh vw

百分比设置

#### git merge和git rebase的区别

#### 埋点

track 

trackFn 

#### useContext provider

#### 可编辑列表是如何实现的？

#### 提供业务可编辑组件的过程，如何设定入参等

#### 虚拟列表是如何实现的，如何解决的滑动过快导致的白屏

#### 前端项目发布的流程，webpack打包后怎样继续发布

打包dist，推送到资源地址上，配置Nginx，部署，重启

#### 使用自定义hooks，如何创建一个自定义hooks，过程及解决了什么问题（例如监听窗口改变或者防抖的自定义hooks）

#### 使用echarts创建地图，及饼状图等

初始化实例对象，配置options 

#### 如何使用屏幕快照截图

cavans

#### diff对比，生成新的DOM树是什么规范，如果全部新增那么不会有任何变化

diff就是找出新旧DOM树的可复用节点，剩下的界面新增的新增，删除的删除

#### fiber是用于解决什么，是什么原理，什么类型的任务先执行，什么任务后执行

解决js代码执行和界面渲染不能同步，js代码复杂组件复杂会导致页面卡顿问题

* 可中断渲染，将渲染任务拆分成小的任务，小任务等到js引擎空余的时候执行，渲染会暂停，渲染时候若遇到优先级高的任务会优先执行用户输入input框或者动画，暂停渲染，出完后再进行后续渲染
* 每个任务有优先级，fiber会根据每个任务的优先级，执行对应的渲染过程，如用户可感知的部分，输入或者动画先执行，数据返回更新界面后执行渲染

#### 微服务

子应用和父应用传参、状态共享问题

#### 技术难点

#### 如何将十个点连成一个平滑的曲线

cavans  贝尔曲线

#### 作用域及作用域链

{}

#### Promise和async、await和generator

#### webpack打包，兼容IE浏览器

loader配置babel将ES6的语法打包为ES5语法

#### ES6新增的属性和方法

#### 使用redux的具体案例，及过程

#### 拦截器，前端路由拦截、http拦截

#### proxy代理

#### token

#### 手写一个输入框，实时查询数据将数据展示在下面

#### 类组件和函数组件有什么区别？

#### 滑动加载定位在某个位置

#### 滑动滚动到最下部时进行第二页数据查询，关闭下拉后默认第一页

单独由另一篇公共滚动下拉组件介绍

 #### null undefiened通过JSON.stringfiy处理后显示

```javascript
JSON.stringify({a:null}) //'{'a':null}'
JSON.stringify({a:undefined}) //{}
```

#### type和interface可以重复定义吗

1. `interface`可以进行重复定义，会进行类型合并，

   extends继承，只适用于类型对象，其常用于引用外部api的类型合并

2. `type`不可以进行重复定义，会报错，

   常用于联合、交叉类型，或者元组等，type可以定义所有类型包括对象类型

   其中` typeof `表示取推论类型`{a:string,b:string,c:string}`

   `keyof`表示取key的类型合集 `a|b|c`

#### symbol和const的区别

symbol用于创建不可重复唯一的值，数据类型

const用于创建不可修改的常量，关键性

`const myName = Symbol('hanjingwen');`

| 特性         | Symbol               | const                      |
| ------------ | -------------------- | -------------------------- |
| 类型         | 基本数据类型         | 关键词                     |
| 用途         | 创建唯一标识符       | 用于定义常量不可修改       |
| 是否唯一     | 每个Symbol是唯一     | 不适用                     |
| 主要使用场景 | 创建对象属性唯一标识 | 定义常量，不可边绑定的变量 |

#### react实现vue的keep-alive功能

使用useMemo，单独提出一个自定义hooks

#### 哪些功能不建议使用useMemo

* 监听定义字符串的时不适用，无性能瓶颈
* 监听频繁变动的属性，比如输入框每次修改都要变化的触发方法
* 监听的值本身是稳定的，例如常量，props，context则不需要使用`useMemo`
* 优化后没有使用性能提升，使用`React DevTools Profiler`

#### 实现自适应的方案和案例

1. 媒查询`Media Queries`
2. 百分比、弹性单位（`vw,vh,em,rem`）
3. `FlexBox`弹性盒子
4. `CSS Grid`布局 高级布局工具，精确控制响应式网格
5. `React+TailwindCss、styled-components`使用类库简化响应式写法

#### useEffect实现了哪些生命周期钩子函数

| 生命周期                             | 对应的useEffect                       | 说明                       |
| ------------------------------------ | ------------------------------------- | -------------------------- |
| componentDidMount                    | useEffect(()=>{},[])                  | 挂载成功后执行一次         |
| componentDidUpdate                   | useEffect(()=>,[deps])                | 状态更新是执行             |
| componentWillUnmount                 | useEffect(()=>{},return ()=>{}[deps]) | 组件将要卸载前执行         |
| componentDidMount/componentDidUpdate | useEffect(()=>{})                     | 组件首次及每次更新都会执行 |

#### redux

#### useReducer

#### 同一个弹窗，a,b切换很快，导致b显示a的内容，通过给组件绑定key区别组件展示

#### 如何实现项目的埋点

实现项目的埋点：可以通过react-gt4实现

#### 类组件和函数组件的区别和各自优势

| 类组件                    | 函数组件         |
| ------------------------- | ---------------- |
| 生命周期函数              | hooks useEffect  |
| this                      | state setState   |
| Class                     | Function ()=>{}  |
| 高阶函数 render Props     | 自定义hooks      |
| 优化shouldComponentUpdate | 优化React.memo() |

#### 二分查找法

```javascript
71
const findNum = (num,arr)=>{
    let left = 0
    let right = arr.length/2-1
    let count = 0
    while(arr[left] !== num){
        count++
        if(num < right){
            left = right/2
        }else{
            right= arr.length-1
        }
        
    }
    return left
}
```

#### 轮询查询

```javascript
  useEffect(() => {
    if (isOpen) {
      //开启轮询查询
      LoopSearch();
    } else {
      //清除輪詢
      clearInterval(timer);
    }
    //弹窗关闭销毁循环定时器
    return () => {
      clearInterval(timer);
    };
  }, [isOpen]);

  /**
   * @description: 轮询查询新建导入数据结果
   * @return {*}
   */
  const LoopSearch = () => {
    timer = setInterval(() => {
      //查找新建导入数据是否成功
      crmApi
        .getKbankSettlementTransferImportFinishCheck({ settlementTransferId: isCreateId })
        .then((res) => {
          //查询新建导入成功
          if (res?.data?.finish) {
            //清除轮询查询
            clearInterval(timer);
            //存在重複的結算轉賬編號
            if (res?.data?.repeatedSettlementTransferDetailNo?.length > 0) {
              //彈窗提示重複的編號
              setIsTipsModal(true);
              setRepeatDetail(res?.data);
            } else {
              //創建导入成功不存在重複，直接跳转到详情界面
              history.push({
                pathname: `/kbank/walletPaymentTransfer/detail/${isCreateId}`,
              });
            }
          }
        })
        .catch((e) => {
          console.log(e);
          //接口失敗停止輪詢
          clearInterval(timer);
          setIsCreating(false);
        });
    }, 2000);
  };
```

#### 文件上传三种类型

* File类型
* Blob文件流形式
* {filename:下载测试文件.txt",downLoadAdrress:'http://asd.txt'}

#### 配置 husky commit格式化和校验

#### Umi中使用useModel('@@initialState')

```javascript
//在app.ts中配置 
function getInitialState(){
 const userInfo =  api.getUser()
  const MerInfo  api.getMerchants()
    return{
        userInfo:{...userInfo},
        MerInfo:{...MerInfo},
    }
}
//可以在任意界面使用
const {initialState,setState,loading,error} = useModel('@@initialState');

//获取用户数据
initialState?.userInfo
```

#### **设计一个公共组件的整个流程**

#### Vue和React和angular有什么相同与不同

相同：

* 都使用虚拟DOM
* 组件化
* 都在逐步实现函数化编程

不同：

* 设计原理不同
* diff算法不同
* react函数式组件和vue3.0的setUp式函数编程
* 适用场景不同

```javascript
<Setup>
</Setup>
```

#### 内存泄漏

* 有哪些原因会导致内存泄露
  1. 在页面中编写定时器，页面销毁时未清除
  2. 在页面中绑定监听器，`addEventListener`页面销毁清除监听` removeEventListener`
  3. 页面中的全局变量 window.data = 1231
  4. 页面代码中闭包中的变量，组件销毁时，js垃圾回收机制，无法触及到闭包中的变量，则无法清除，
* js的垃圾回收机制
* 检查定位和修复内存泄露
  1. 通过devTool
  2. Memory面板 使用Heap Snapshot 找出无法回收的对象
  3. Timeline分析观察内存占用是否持续增长

```javascript
console.log('script start');

setTimeout(() => {
  console.log('setTimeout');
}, 0);

async function async1() {
  console.log('async1 start');
  await Promise.resolve().then(() => {
    console.log('promise1');
  });
  console.log('async1 end');
}

async1();

console.log('script end');

//结果：
script start
async1 start
script end
promise1
async end
setTimeout
```

#### 用`async`和`promise`实现红绿灯交替展示

 实现一个红绿灯交替展示的功能，要求红灯亮 3 秒，绿灯亮 2 秒，黄灯亮 1 秒，循环往复。使用 `async` 和 `Promise` 实现。

```javascript
```

#### 使用reduce分组数组项

```javascript
const people = [
  { name: 'Alice', role: 'admin' },
  { name: 'Bob', role: 'user' },
  { name: 'Charlie', role: 'admin' },
];

const newArr = people.reduce((cur,item)=>{
    cur[item.role] = (cur[item.role]||[]).push({name:item.name})
},{})
```

#### Reduce

#### npm install以后发生了什么

**`node package manager`** node安装包管理工具

![npm install流程](D:\PrivateFiles\Note\复习笔记\img\npm install流程.png)

**`npm`**是嵌套结构，安装时通过递归进行遍历父依赖及子级依赖，下载生成扁平结构modules安装包树结构。

**`.npmc`**是控制安装包下载依赖的路径，或者下载的镜像，企业私库等。控制npm的行为，如注册、代理、缓存路径等

**`pnpm.lock`**文件 **锁定依赖树的精确版本** ，记录安装包版本，记录线上安装包版本和本地安装包版本是否一致，package.json中的安装包存在版本范围，lock中记录了该依赖包的精准版本

**整个流程：**

1. 是否有--save安装命令，如果有走save版本，按照package.json记录的依赖包版本下载，

2. 获取`.npmc`的项目配置，如安装包版本依赖库地址，代理，镜像等 

3. 检查是否有lock文件，存在则检查json依赖版本和lock版本是否一致，是否存在缓存，下载后在modules文件中生成对应的包，最后更新lock文件。

#### 微前端实现方案及步骤

```javascript
```

#### 解决项目中同样接口重复请求问题

例如，列表中每一条数据都需要请求接口获取字典进行翻译，如何解决重复请求接口问题

#### 解决项目里的数据字典值，是用到了再去拿，还是第一次就完整拿？拿到了要不要缓存？怎么更新

#### JS内存泄漏内存垃圾回收用什么

1. 垃圾回收GC

   外部有引用的，且闭包内的变量和方法也是被引用的

   * 什么是垃圾回收机制
     * 引用计数（历史）：垃圾回收机制算法，对象被引用的数量为0则可以进行垃圾回收，缺陷：循环引用无法清除，a对象为b对象的引用，b又为a的引用
     * 标记清除（现在）：从window遍历各个子属性，如果得到属性就保留，得不到就清除
   * 闭包是内存泄漏吗
     * 不可预期的数据不能进行垃圾回收不可进行内存回收，闭包是可预期的
     * 但是闭包内的数据是不能进行垃圾回收的
   * 

#### Vue的每个生命周期都做了什么

#### Vue2 Vue3 React的diff都是做了什么
